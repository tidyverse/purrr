---
title: "Programming with purrr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Programming with purrr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette contains some details of using programming with purrr specifically when you're using it from a package.

```{r setup}
library(purrr)
```

## Errors

(This section assumes that you're familiar with the basics of error handling in R, as described in [Advanced R](https://adv-r.hadley.nz/conditions.html)).

As of purrr 1.0.0, `map()` and friends wrap all errors generated by `.f` inside another error that gives the iteration index where the problem occurred.
Let's take a look at the details with a simple example:

```{r}
#| error: true
f <- function(x) {
  if (x == 3) {
    rlang::abort("`x` must not be 3")
  } else {
    x / (x - 3)
  }
} 

map(c(1, 4, 2, 5, 3), f)
```

How does this work?
Let's take a look at the condition object, which we can capture with `rlang::catch_cnd().`

```{r}
cnd <- rlang::catch_cnd(map(c(1, 4, 2, 5, 3), f))
```

This condition has a custom class[^1] telling us that it's specifically from a map function:

[^1]: As of purrr 1.0.1.

```{r}
class(cnd)
```

We can also extract the index:

```{r}
cnd$index
```

And get the original error:

```{r}
cnd$parent
```

This chaining is really useful when doing interactive data analysis, but it adds some extra complexity if you have your own error handling.
Let's make `f` a bit more complicated by adding a custom class:

```{r}
#| error: true 
f <- function(x) {
  if (x == 3) {
    rlang::abort("`x` must not be 3", class = "my_error")
  } else {
    x / (x - 3)
  }
} 
map(c(1, 4, 2, 5, 3), f)
```

This doesn't change the visual display, but you're likely to be surprised if you're using `tryCatch()` to handle some error generated in a `map()`:

```{r}
#| error: true
tryCatch(
  map(c(1, 4, 2, 5, 3), f),
  my_error = function(err) {
    print("Hello! why am I not being called?")
  }
)
```

That's because, as described above, the error is wrapped inside the `purrr_error_indexed` class, so you need to do a bit more work:

```{r}
tryCatch(
  map(c(1, 4, 2, 5, 3), f),
  purrr_error_indexed = function(err) {
    if (rlang::cnd_inherits(err$parent, "my_error")) {
      print("Hello! I am now called :)")
    } else {
      rlang::cnd_signal(err)
    }
  }
)
```

If you just want to get rid of purrr's wrapper, you can do this:

```{r}
#| error: true
tryCatch(
  map(c(1, 4, 2, 5, 3), f),
  purrr_error_indexed = function(err) {
    rlang::cnd_signal(err$parent)
  }
)
```
