---
title: "Programming with purrr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Programming with purrr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette contains some details of using programming with purrr specifically when you're using it from a package.

```{r setup}
library(purrr)
```

## Errors

(This section assumes that you're familiar with the basics of error handling in R, as described in [Advanced R](https://adv-r.hadley.nz/conditions.html). We focus on tools from rlang since they allow us to omit some details; you can also achieve similar results with pure R code if needed.)

As of purrr 1.0.0, `map()` and friends wrap all errors generated by `.f` inside another error that gives the iteration index where the problem occurred.
Let's take a look at the details with a simple example:

```{r}
#| error: true
f <- function(x) {
  if (x == 3) {
    rlang::abort("`x` must not be 3")
  } else {
    x / (x - 3)
  }
} 

map(c(1, 4, 2, 5, 3), f)
```

How does this work?
Let's take a look at the condition object, which we can capture with `rlang::catch_cnd().`

```{r}
cnd <- rlang::catch_cnd(map(c(1, 4, 2, 5, 3), f))
```

This condition has a custom class[^1] telling us that it's specifically from a map function:

[^1]: As of purrr 1.0.1.

```{r}
class(cnd)
```

It also contains the location:

```{r}
cnd$location
```

And the original error:

```{r}
cnd$parent
```

If the input vector has names, the error will have a non-`NULL` name component:

```{r}
cnd <- rlang::catch_cnd(map(c(a = 1, b = 3, c = 2), f))
cnd$location
cnd$name
```

This error chaining is really useful when doing interactive data analysis, but it adds some extra complexity when handling errors with `tryCatch()` or `withCallingHandlers()`.
Let's see what happens by adding a custom class to the error thrown by `f()`:

```{r}
#| error: true 
f <- function(x) {
  if (x == 3) {
    rlang::abort("`x` must not be 3", class = "my_error")
  } else {
    x / (x - 3)
  }
} 
map(c(1, 4, 2, 5, 3), f)
```

This doesn't change the visual display, but you might be surprised if you try to catch this error with `tryCatch()`:

```{r}
#| error: true
tryCatch(
  map(c(1, 4, 2, 5, 3), f),
  my_error = function(err) {
    print("Hello! why am I not being called?")
  }
)
```

That's because, as described above, the error that `map()` throws will always have class `purrr_error_indexed`:

```{r}
tryCatch(
  map(c(1, 4, 2, 5, 3), f),
  purrr_error_indexed = function(err) {
    print("Hello! I am now called :)")
  }
)
```

In order to handle the error thrown by `f()`, you'll need to use `rlang::cnd_inherits()` on the parent error:

```{r}
tryCatch(
  map(c(1, 4, 2, 5, 3), f),
  purrr_error_indexed = function(err) {
    if (rlang::cnd_inherits(err$parent, "my_error")) {
      print("Hello! I am now called :)")
    } else {
      rlang::cnd_signal(err)
    }
  }
)
```

The pattern is slightly simpler if you're using `withCallingHandlers()` instead of `tryCatch()` since errors will automatically bubble up:

```{r}
#| error: true

withCallingHandlers(
  map(c(1, 4, 2, 5, 3), f),
  purrr_error_indexed = function(err) {
    if (rlang::cnd_inherits(err$parent, "my_error")) {
      print("Hello! I am now called :)")
    }
  }
)
```

Finally, if you just want to get rid of purrr's wrapper error, you can resignal the parent error:

```{r}
#| error: true
tryCatch(
  map(c(1, 4, 2, 5, 3), f),
  purrr_error_indexed = function(err) {
    rlang::cnd_signal(err$parent)
  }
)
```
