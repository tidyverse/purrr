[{"path":[]},{"path":"https://purrr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://purrr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://purrr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://purrr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://purrr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement codeofconduct@posit.co. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://purrr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://purrr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://purrr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://purrr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://purrr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://purrr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://purrr.tidyverse.org/dev/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to purrr","title":"Contributing to purrr","text":"outlines propose change purrr. detailed info contributing , tidyverse packages, please see development contributing guide.","code":""},{"path":"https://purrr.tidyverse.org/dev/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to purrr","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"https://purrr.tidyverse.org/dev/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to purrr","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed).","code":""},{"path":"https://purrr.tidyverse.org/dev/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to purrr","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"batpigandme/purrr\", fork = TRUE). Install development dependences devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"https://purrr.tidyverse.org/dev/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to purrr","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"https://purrr.tidyverse.org/dev/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to purrr","text":"Please note purrr project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://purrr.tidyverse.org/dev/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 purrr authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://purrr.tidyverse.org/dev/SUPPORT.html","id":null,"dir":"","previous_headings":"","what":"Getting help with purrr","title":"Getting help with purrr","text":"Thanks using purrr! filing issue, places explore pieces put together make process smooth possible.","code":""},{"path":"https://purrr.tidyverse.org/dev/SUPPORT.html","id":"make-a-reprex","dir":"","previous_headings":"","what":"Make a reprex","title":"Getting help with purrr","text":"Start making minimal reproducible example using reprex package. haven’t heard used reprex , ’re treat! Seriously, reprex make R-question-asking endeavors easier (pretty insane ROI five ten minutes ’ll take learn ’s ). additional reprex pointers, check Get help! section tidyverse site.","code":""},{"path":"https://purrr.tidyverse.org/dev/SUPPORT.html","id":"where-to-ask","dir":"","previous_headings":"","what":"Where to ask?","title":"Getting help with purrr","text":"Armed reprex, next step figure ask. ’s question: start community.rstudio.com, /StackOverflow. people answer questions. ’s bug: ’re right place, file issue. ’re sure: let community help figure ! problem bug feature request, can easily return report . opening new issue, sure search issues pull requests make sure bug hasn’t reported /already fixed development version. default, search pre-populated :issue :open. can edit qualifiers (e.g. :pr, :closed) needed. example, ’d simply remove :open search issues repo, open closed.","code":""},{"path":"https://purrr.tidyverse.org/dev/SUPPORT.html","id":"what-happens-next","dir":"","previous_headings":"","what":"What happens next?","title":"Getting help with purrr","text":"efficient possible, development tidyverse packages tends bursty, shouldn’t worry don’t get immediate response. Typically don’t look repo sufficient quantity issues accumulates, ’s burst intense activity focus efforts. makes development efficient avoids expensive context switching problems, cost taking longer get back . process makes good reprex particularly important might multiple months initial report start working . can’t reproduce bug, can’t fix !","code":""},{"path":"https://purrr.tidyverse.org/dev/articles/base.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"purrr <-> base R","text":"vignette compares purrr’s functionals base R equivalents, focusing primarily map family related functions. helps familiar base R understand better purrr , shows purrr users might express ideas base R code. ’ll start rough overview major differences, give rough translation guide, show examples.","code":"library(purrr) library(tibble)"},{"path":"https://purrr.tidyverse.org/dev/articles/base.html","id":"key-differences","dir":"Articles","previous_headings":"Introduction","what":"Key differences","title":"purrr <-> base R","text":"two primary differences base apply family purrr map family: purrr functions named consistently, fully explore space input output variants. purrr functions consistently use . prefix avoid inadvertently matching arguments purrr function, instead function ’re trying call. Base functions use variety techniques including upper case (e.g. lapply(X, FUN, ...)) require anonymous functions (e.g. Map()). map functions type stable: can predict type output using little information inputs. contrast, base functions sapply() mapply() automatically simplify making return value hard predict. map functions start data, followed function, additional constant argument. base apply functions also follow pattern, mapply() starts function, Map() way supply additional constant arguments. purrr functions provide combinations input output variants, include variants specifically common two argument case.","code":""},{"path":"https://purrr.tidyverse.org/dev/articles/base.html","id":"direct-translations","dir":"Articles","previous_headings":"Introduction","what":"Direct translations","title":"purrr <-> base R","text":"following sections give high-level translation base R commands purrr equivalents. See function documentation details.","code":""},{"path":"https://purrr.tidyverse.org/dev/articles/base.html","id":"map-functions","dir":"Articles","previous_headings":"Introduction > Direct translations","what":"Map functions","title":"purrr <-> base R","text":"x denotes vector f denotes function","code":""},{"path":"https://purrr.tidyverse.org/dev/articles/base.html","id":"extractor-shorthands","dir":"Articles","previous_headings":"Introduction > Direct translations","what":"Extractor shorthands","title":"purrr <-> base R","text":"Since common use case map functions list extracting components, purrr provides handful shortcut functions various uses [[.","code":""},{"path":"https://purrr.tidyverse.org/dev/articles/base.html","id":"predicates","dir":"Articles","previous_headings":"Introduction > Direct translations","what":"Predicates","title":"purrr <-> base R","text":"p, predicate, denotes function returns TRUE FALSE indicating whether object fulfills criterion, e.g. .character().","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/articles/base.html","id":"one-input","dir":"Articles","previous_headings":"Introduction > Examples > Varying inputs","what":"One input","title":"purrr <-> base R","text":"Suppose like generate list samples 5 normal distributions different means: ’s little difference generating samples: Base R uses lapply(): purrr uses map():","code":"means <- 1:4 set.seed(2020) samples <- lapply(means, rnorm, n = 5, sd = 1) str(samples) #> List of 4 #>  $ : num [1:5] 1.377 1.302 -0.098 -0.13 -1.797 #>  $ : num [1:5] 2.72 2.94 1.77 3.76 2.12 #>  $ : num [1:5] 2.15 3.91 4.2 2.63 2.88 #>  $ : num [1:5] 5.8 5.704 0.961 1.711 4.058 set.seed(2020) samples <- map(means, rnorm, n = 5, sd = 1) str(samples) #> List of 4 #>  $ : num [1:5] 1.377 1.302 -0.098 -0.13 -1.797 #>  $ : num [1:5] 2.72 2.94 1.77 3.76 2.12 #>  $ : num [1:5] 2.15 3.91 4.2 2.63 2.88 #>  $ : num [1:5] 5.8 5.704 0.961 1.711 4.058"},{"path":"https://purrr.tidyverse.org/dev/articles/base.html","id":"two-inputs","dir":"Articles","previous_headings":"Introduction > Examples > Varying inputs","what":"Two inputs","title":"purrr <-> base R","text":"Lets make example little complicated also varying standard deviations: relatively tricky base R adjust number mapply()’s defaults. Alternatively, use Map() doesn’t simply, also doesn’t take constant arguments, need use anonymous function: R 4.1 , use shorter anonymous function form: Working pair vectors common situation purrr provides map2() family functions:","code":"means <- 1:4 sds <- 1:4 set.seed(2020) samples <- mapply(   rnorm,    mean = means,    sd = sds,    MoreArgs = list(n = 5),    SIMPLIFY = FALSE ) str(samples) #> List of 4 #>  $ : num [1:5] 1.377 1.302 -0.098 -0.13 -1.797 #>  $ : num [1:5] 3.44 3.88 1.54 5.52 2.23 #>  $ : num [1:5] 0.441 5.728 6.589 1.885 2.63 #>  $ : num [1:5] 11.2 10.82 -8.16 -5.16 4.23 samples <- Map(function(...) rnorm(..., n = 5), mean = means, sd = sds) samples <- Map(\\(...) rnorm(..., n = 5), mean = means, sd = sds) set.seed(2020) samples <- map2(means, sds, rnorm, n = 5) str(samples) #> List of 4 #>  $ : num [1:5] 1.377 1.302 -0.098 -0.13 -1.797 #>  $ : num [1:5] 3.44 3.88 1.54 5.52 2.23 #>  $ : num [1:5] 0.441 5.728 6.589 1.885 2.63 #>  $ : num [1:5] 11.2 10.82 -8.16 -5.16 4.23"},{"path":"https://purrr.tidyverse.org/dev/articles/base.html","id":"any-number-of-inputs","dir":"Articles","previous_headings":"Introduction > Examples > Varying inputs","what":"Any number of inputs","title":"purrr <-> base R","text":"can make challenge still complex also varying number samples: Using base R’s Map() becomes straightforward constant arguments. purrr, need switch map2() pmap() takes list number arguments.","code":"ns <- 4:1 set.seed(2020) samples <- Map(rnorm, mean = means, sd = sds, n = ns) str(samples) #> List of 4 #>  $ : num [1:4] 1.377 1.302 -0.098 -0.13 #>  $ : num [1:3] -3.59 3.44 3.88 #>  $ : num [1:2] 2.31 8.28 #>  $ : num 4.47 set.seed(2020) samples <- pmap(list(mean = means, sd = sds, n = ns), rnorm) str(samples) #> List of 4 #>  $ : num [1:4] 1.377 1.302 -0.098 -0.13 #>  $ : num [1:3] -3.59 3.44 3.88 #>  $ : num [1:2] 2.31 8.28 #>  $ : num 4.47"},{"path":"https://purrr.tidyverse.org/dev/articles/base.html","id":"outputs","dir":"Articles","previous_headings":"Introduction > Examples","what":"Outputs","title":"purrr <-> base R","text":"Given samples, imagine want compute means. mean single number, want output numeric vector rather list. two options base R: vapply() sapply(). vapply() requires specific output type (relatively verbose), always return numeric vector. sapply() concise, supply empty list ’ll get list instead numeric vector. purrr little compact can use map_dbl(). want just side effect, plot file output, returned values? base R can either use loop hide results lapply. purrr, can use walk().","code":"# type stable medians <- vapply(samples, median, FUN.VALUE = numeric(1L)) medians #> [1] 0.6017626 3.4411470 5.2946304 4.4694671  # not type stable medians <- sapply(samples, median) medians <- map_dbl(samples, median) medians #> [1] 0.6017626 3.4411470 5.2946304 4.4694671 # for loop for (s in samples) {   hist(s, xlab = \"value\", main = \"\") }  # lapply invisible(lapply(samples, function(s) {   hist(s, xlab = \"value\", main = \"\") })) walk(samples, ~ hist(.x, xlab = \"value\", main = \"\"))"},{"path":"https://purrr.tidyverse.org/dev/articles/base.html","id":"pipes","dir":"Articles","previous_headings":"Introduction > Examples","what":"Pipes","title":"purrr <-> base R","text":"can join multiple steps together pipe: pipe particularly compelling working longer transformations. example, following code splits mtcars cyl, fits linear model, extracts coefficients, extracts first one (intercept).","code":"set.seed(2020) means |>   map(rnorm, n = 5, sd = 1) |>   map_dbl(median) #> [1] -0.09802317  2.72057350  2.87673977  4.05830349 mtcars |>   split(mtcars$cyl) |>    map(\\(df) lm(mpg ~ wt, data = df))|>    map(coef) |>    map_dbl(1) #>        4        6        8  #> 39.57120 28.40884 23.86803"},{"path":"https://purrr.tidyverse.org/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Hadley Wickham. Author, maintainer. Lionel Henry. Author. . Copyright holder, funder.","code":""},{"path":"https://purrr.tidyverse.org/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wickham H, Henry L (2025). purrr: Functional Programming Tools. R package version 1.1.0.9000, https://purrr.tidyverse.org/.","code":"@Manual{,   title = {purrr: Functional Programming Tools},   author = {Hadley Wickham and Lionel Henry},   year = {2025},   note = {R package version 1.1.0.9000},   url = {https://purrr.tidyverse.org/}, }"},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Functional Programming Tools","text":"purrr enhances R’s functional programming (FP) toolkit providing complete consistent set tools working functions vectors. ’ve never heard FP , best place start family map() functions allow replace many loops code succinct easier read. best place learn map() functions iteration chapter R Data Science.","code":""},{"path":"https://purrr.tidyverse.org/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Functional Programming Tools","text":"","code":"# The easiest way to get purrr is to install the whole tidyverse: install.packages(\"tidyverse\")  # Alternatively, install just purrr: install.packages(\"purrr\")  # Or the the development version from GitHub: # install.packages(\"pak\") pak::pak(\"tidyverse/purrr\")"},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Functional Programming Tools","text":"following example uses purrr solve fairly realistic problem: split data frame pieces, fit model piece, compute summary, extract R2. example illustrates advantages purrr functions equivalents base R: first argument always data, purrr works naturally pipe. purrr functions type-stable. always return advertised output type (map() returns lists; map_dbl() returns double vectors), throw error. map() functions accept functions (named, anonymous, lambda), character vector (used extract components name), numeric vectors (used extract position). two less obvious advantages: map() functions .progress argument can easily track progress long running jobs. map() functions work in_parallel() easily spread computation across multiple cores computer, multiple machines network.","code":"library(purrr)  mtcars |>    split(mtcars$cyl) |>  # from base R   map(\\(df) lm(mpg ~ wt, data = df)) |>    map(summary) |>   map_dbl(\"r.squared\") #>         4         6         8  #> 0.5086326 0.4645102 0.4229655"},{"path":"https://purrr.tidyverse.org/dev/reference/accumulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Accumulate intermediate results of a vector reduction — accumulate","title":"Accumulate intermediate results of a vector reduction — accumulate","text":"accumulate() sequentially applies 2-argument function elements vector. application function uses initial value result previous application first argument. second argument next value vector. results application returned list. accumulation can optionally terminate processing whole vector response done() signal returned accumulation function. contrast accumulate(), reduce() applies 2-argument function way, discards results except final function application. accumulate2() sequentially applies function elements two lists, .x .y.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/accumulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Accumulate intermediate results of a vector reduction — accumulate","text":"","code":"accumulate(   .x,   .f,   ...,   .init,   .dir = c(\"forward\", \"backward\"),   .simplify = NA,   .ptype = NULL )  accumulate2(.x, .y, .f, ..., .init, .simplify = NA, .ptype = NULL)"},{"path":"https://purrr.tidyverse.org/dev/reference/accumulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Accumulate intermediate results of a vector reduction — accumulate","text":".x list atomic vector. .f accumulate() .f 2-argument function. function passed accumulated result initial value first argument. next value sequence passed second argument. accumulate2(), 3-argument function. function passed accumulated result first argument. next value sequence .x passed second argument. next value sequence .y passed third argument. accumulation terminates early .f returns value wrapped done(). ... Additional arguments passed mapped function. now generally recommend using ... pass additional (constant) arguments .f. Instead use shorthand anonymous function:   makes easier understand arguments belong function tend yield better error messages. .init supplied, used first value start accumulation, rather using .x[[1]]. useful want ensure reduce returns correct value .x empty. missing, .x empty, throw error. .dir direction accumulation string, one \"forward\" (default) \"backward\". See section direction . .simplify NA, default, accumulated list results simplified atomic vector possible. TRUE, result simplified, erroring possible. FALSE, result simplified, always returning list. .ptype simplify NA TRUE, optionally supply vector prototype enforce output type. .y accumulate2() .y second argument pair. needs 1 element shorter vector accumulated (.x). .init set, .y needs one element shorted concatenation initial value .x.","code":"# Instead of x |> map(f, 1, 2, collapse = \",\") # do: x |> map(\\(x) f(x, 1, 2, collapse = \",\"))"},{"path":"https://purrr.tidyverse.org/dev/reference/accumulate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Accumulate intermediate results of a vector reduction — accumulate","text":"vector length .x names .x. .init supplied, length extended 1. .x names, initial value given name \".init\", otherwise returned vector kept unnamed. .dir \"forward\" (default), first element initial value (.init supplied, first element .x) last element final reduced value. case right accumulation, order reversed. accumulation terminates early .f returns value wrapped done(). done box empty, last value used instead result one element shorter (always includes initial value, even terminating first iteration).","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/accumulate.html","id":"direction","dir":"Reference","previous_headings":"","what":"Direction","title":"Accumulate intermediate results of a vector reduction — accumulate","text":".f associative operation like + c(), direction reduction matter. instance, reducing vector 1:3 binary function + computes sum ((1 + 2) + 3) left, sum (1 + (2 + 3)) right. cases, direction important consequences reduced value. instance, reducing vector list() left produces left-leaning nested list (tree), reducing list() right produces right-leaning list.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/accumulate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Accumulate intermediate results of a vector reduction — accumulate","text":"","code":"# With an associative operation, the final value is always the # same, no matter the direction. You'll find it in the first element for a # backward (left) accumulation, and in the last element for forward # (right) one: 1:5 |> accumulate(`+`) #> [1]  1  3  6 10 15 1:5 |> accumulate(`+`, .dir = \"backward\") #> [1] 15 14 12  9  5  # The final value is always equal to the equivalent reduction: 1:5 |> reduce(`+`) #> [1] 15  # It is easier to understand the details of the reduction with # `paste()`. accumulate(letters[1:5], paste, sep = \".\") #> [1] \"a\"         \"a.b\"       \"a.b.c\"     \"a.b.c.d\"   \"a.b.c.d.e\"  # Note how the intermediary reduced values are passed to the left # with a left reduction, and to the right otherwise: accumulate(letters[1:5], paste, sep = \".\", .dir = \"backward\") #> [1] \"a.b.c.d.e\" \"b.c.d.e\"   \"c.d.e\"     \"d.e\"       \"e\"          # By ignoring the input vector (nxt), you can turn output of one step into # the input for the next. This code takes 10 steps of a random walk: accumulate(1:10, \\(acc, nxt) acc + rnorm(1), .init = 0) #>  [1]  0.0000000  0.2553171 -2.1819466 -2.1875178 -1.5659651 -0.4175535 #>  [7] -2.2393712 -2.4866965 -2.7308961 -3.0136015 -3.5673009  # `accumulate2()` is a version of `accumulate()` that works with # 3-argument functions and one additional vector: paste2 <- function(acc, nxt, sep = \".\") paste(acc, nxt, sep = sep) letters[1:4] |> accumulate(paste2) #> [1] \"a\"       \"a.b\"     \"a.b.c\"   \"a.b.c.d\" letters[1:4] |> accumulate2(c(\"-\", \".\", \"-\"), paste2) #> [1] \"a\"       \"a-b\"     \"a-b.c\"   \"a-b.c-d\"  # You can shortcircuit an accumulation and terminate it early by # returning a value wrapped in a done(). In the following example # we return early if the result-so-far, which is passed on the LHS, # meets a condition: paste3 <- function(out, input, sep = \".\") {   if (nchar(out) > 4) {     return(done(out))   }   paste(out, input, sep = sep) } letters |> accumulate(paste3) #> [1] \"a\"     \"a.b\"   \"a.b.c\" \"a.b.c\"  # Note how we get twice the same value in the accumulation. That's # because we have returned it twice. To prevent this, return an empty # done box to signal to accumulate() that it should terminate with the # value of the last iteration: paste3 <- function(out, input, sep = \".\") {   if (nchar(out) > 4) {     return(done())   }   paste(out, input, sep = sep) } letters |> accumulate(paste3) #> [1] \"a\"     \"a.b\"   \"a.b.c\"  # Here the early return branch checks the incoming inputs passed on # the RHS: paste4 <- function(out, input, sep = \".\") {   if (input == \"f\") {     return(done())   }   paste(out, input, sep = sep) } letters |> accumulate(paste4) #> [1] \"a\"         \"a.b\"       \"a.b.c\"     \"a.b.c.d\"   \"a.b.c.d.e\"   # Simulating stochastic processes with drift if (FALSE) { # \\dontrun{ library(dplyr) library(ggplot2)  map(1:5, \\(i) rnorm(100)) |>   set_names(paste0(\"sim\", 1:5)) |>   map(\\(l) accumulate(l, \\(acc, nxt) .05 + acc + nxt)) |>   map(\\(x) tibble(value = x, step = 1:100)) |>   list_rbind(names_to = \"simulation\") |>   ggplot(aes(x = step, y = value)) +     geom_line(aes(color = simulation)) +     ggtitle(\"Simulations of a random walk with drift\") } # }"},{"path":"https://purrr.tidyverse.org/dev/reference/along.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a list of given length — along","title":"Create a list of given length — along","text":"function deprecated purrr 1.0.0 since related core purpose purrr. can useful create empty list plan fill later. similar idea seq_along(), creates vector length input.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/along.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a list of given length — along","text":"","code":"list_along(x)"},{"path":"https://purrr.tidyverse.org/dev/reference/along.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a list of given length — along","text":"x vector.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/along.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a list of given length — along","text":"list length x.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/along.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a list of given length — along","text":"","code":"x <- 1:5 seq_along(x) #> [1] 1 2 3 4 5 list_along(x) #> Warning: `list_along()` was deprecated in purrr 1.0.0. #> ℹ Please use rep_along(x, list()) instead. #> [[1]] #> NULL #>  #> [[2]] #> NULL #>  #> [[3]] #> NULL #>  #> [[4]] #> NULL #>  #> [[5]] #> NULL #>"},{"path":"https://purrr.tidyverse.org/dev/reference/array-coercion.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce array to list — array-coercion","title":"Coerce array to list — array-coercion","text":"array_branch() array_tree() enable arrays used purrr's functionals turning lists. details coercion controlled margin argument. array_tree() creates hierarchical list (tree) many levels dimensions specified margin, array_branch() creates flat list (analogy, branch) along mentioned dimensions.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/array-coercion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce array to list — array-coercion","text":"","code":"array_branch(array, margin = NULL)  array_tree(array, margin = NULL)"},{"path":"https://purrr.tidyverse.org/dev/reference/array-coercion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce array to list — array-coercion","text":"array array coerce list. margin numeric vector indicating positions indices enlisted. NULL, full margin used. numeric(0), array whole wrapped list.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/array-coercion.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coerce array to list — array-coercion","text":"margin specified, dimensions used default. margin numeric vector length zero, whole array wrapped list.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/array-coercion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce array to list — array-coercion","text":"","code":"# We create an array with 3 dimensions x <- array(1:12, c(2, 2, 3))  # A full margin for such an array would be the vector 1:3. This is # the default if you don't specify a margin  # Creating a branch along the full margin is equivalent to # as.list(array) and produces a list of size length(x): array_branch(x) |> str() #> List of 12 #>  $ : int 1 #>  $ : int 2 #>  $ : int 3 #>  $ : int 4 #>  $ : int 5 #>  $ : int 6 #>  $ : int 7 #>  $ : int 8 #>  $ : int 9 #>  $ : int 10 #>  $ : int 11 #>  $ : int 12  # A branch along the first dimension yields a list of length 2 # with each element containing a 2x3 array: array_branch(x, 1) |> str() #> List of 2 #>  $ : int [1:2, 1:3] 1 3 5 7 9 11 #>  $ : int [1:2, 1:3] 2 4 6 8 10 12  # A branch along the first and third dimensions yields a list of # length 2x3 whose elements contain a vector of length 2: array_branch(x, c(1, 3)) |> str() #> List of 6 #>  $ : int [1:2] 1 3 #>  $ : int [1:2] 2 4 #>  $ : int [1:2] 5 7 #>  $ : int [1:2] 6 8 #>  $ : int [1:2] 9 11 #>  $ : int [1:2] 10 12  # Creating a tree from the full margin creates a list of lists of # lists: array_tree(x) |> str() #> List of 2 #>  $ :List of 2 #>   ..$ :List of 3 #>   .. ..$ : int 1 #>   .. ..$ : int 5 #>   .. ..$ : int 9 #>   ..$ :List of 3 #>   .. ..$ : int 3 #>   .. ..$ : int 7 #>   .. ..$ : int 11 #>  $ :List of 2 #>   ..$ :List of 3 #>   .. ..$ : int 2 #>   .. ..$ : int 6 #>   .. ..$ : int 10 #>   ..$ :List of 3 #>   .. ..$ : int 4 #>   .. ..$ : int 8 #>   .. ..$ : int 12  # The ordering and the depth of the tree are controlled by the # margin argument: array_tree(x, c(3, 1)) |> str() #> List of 3 #>  $ :List of 2 #>   ..$ : int [1:2] 1 3 #>   ..$ : int [1:2] 2 4 #>  $ :List of 2 #>   ..$ : int [1:2] 5 7 #>   ..$ : int [1:2] 6 8 #>  $ :List of 2 #>   ..$ : int [1:2] 9 11 #>   ..$ : int [1:2] 10 12"},{"path":"https://purrr.tidyverse.org/dev/reference/as_mapper.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an object into a mapper function — as_mapper","title":"Convert an object into a mapper function — as_mapper","text":"as_mapper powerhouse behind varied function specifications purrr functions allow. S3 generic. default method forwards arguments rlang::as_function().","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/as_mapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an object into a mapper function — as_mapper","text":"","code":"as_mapper(.f, ...)  # S3 method for class 'character' as_mapper(.f, ..., .null, .default = NULL)  # S3 method for class 'numeric' as_mapper(.f, ..., .null, .default = NULL)  # S3 method for class 'list' as_mapper(.f, ..., .null, .default = NULL)"},{"path":"https://purrr.tidyverse.org/dev/reference/as_mapper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an object into a mapper function — as_mapper","text":".f function, formula, vector (necessarily atomic). function, used . formula, e.g. ~ .x + 2, converted function. longer recommended. character vector, numeric vector, list, converted extractor function. Character vectors index name numeric vectors index position; use list index position name different levels. component present, value .default returned. ... Additional arguments passed methods. .default, .null Optional additional argument extractor functions (.e. .f character, integer, list). Returned value absent (exist) empty (length 0). .null deprecated; please use .default instead.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/as_mapper.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert an object into a mapper function — as_mapper","text":"","code":"as_mapper(\\(x) x + 1) #> function (x)  #> x + 1 #> <environment: 0x55826f031648> as_mapper(1) #> function (x, ...)  #> pluck_raw(x, list(1), .default = NULL) #> <environment: 0x55826efe5c90>  as_mapper(c(\"a\", \"b\", \"c\")) #> function (x, ...)  #> pluck_raw(x, list(\"a\", \"b\", \"c\"), .default = NULL) #> <environment: 0x55826efabc20> # Equivalent to function(x) x[[\"a\"]][[\"b\"]][[\"c\"]]  as_mapper(list(1, \"a\", 2)) #> function (x, ...)  #> pluck_raw(x, list(1, \"a\", 2), .default = NULL) #> <environment: 0x55826ec09f60> # Equivalent to function(x) x[[1]][[\"a\"]][[2]]  as_mapper(list(1, attr_getter(\"a\"))) #> function (x, ...)  #> pluck_raw(x, list(1, function (x)  #> attr(x, attr, exact = TRUE)), .default = NULL) #> <environment: 0x55826eb06a20> # Equivalent to function(x) attr(x[[1]], \"a\")  as_mapper(c(\"a\", \"b\", \"c\"), .default = NA) #> function (x, ...)  #> pluck_raw(x, list(\"a\", \"b\", \"c\"), .default = NA) #> <environment: 0x55826e7b9760>"},{"path":"https://purrr.tidyverse.org/dev/reference/as_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce a list to a vector — as_vector","title":"Coerce a list to a vector — as_vector","text":"functions superseded purrr 1.0.0 favour list_simplify() consistent semantics based vctrs principles: as_vector(x) now list_simplify(x) simplify(x) now list_simplify(x, strict = FALSE) simplify_all(x) map(x, list_simplify, strict = FALSE) Superseded functions go away, receive critical bug fixes.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/as_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce a list to a vector — as_vector","text":"","code":"as_vector(.x, .type = NULL)  simplify(.x, .type = NULL)  simplify_all(.x, .type = NULL)"},{"path":"https://purrr.tidyverse.org/dev/reference/as_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce a list to a vector — as_vector","text":".x list vectors .type Can vector mold specifying type length vectors concatenated, numeric(1) integer(4). Alternatively, can string describing type, one : \"logical\", \"integer\", \"double\", \"complex\", \"character\" \"raw\".","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/as_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce a list to a vector — as_vector","text":"","code":"# was as.list(letters) |> as_vector(\"character\") #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" #> [17] \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" # now as.list(letters) |> list_simplify(ptype = character()) #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" #> [17] \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"  # was: list(1:2, 3:4, 5:6) |> as_vector(integer(2)) #> [1] 1 2 3 4 5 6 # now: list(1:2, 3:4, 5:6) |> list_c(ptype = integer()) #> [1] 1 2 3 4 5 6"},{"path":"https://purrr.tidyverse.org/dev/reference/attr_getter.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an attribute getter function — attr_getter","title":"Create an attribute getter function — attr_getter","text":"attr_getter() generates attribute accessor function; .e., generates function extracting attribute given name. Unlike base R attr() function default options, use partial matching.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/attr_getter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an attribute getter function — attr_getter","text":"","code":"attr_getter(attr)"},{"path":"https://purrr.tidyverse.org/dev/reference/attr_getter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an attribute getter function — attr_getter","text":"attr attribute name string.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/attr_getter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an attribute getter function — attr_getter","text":"","code":"# attr_getter() takes an attribute name and returns a function to # access the attribute: get_rownames <- attr_getter(\"row.names\") get_rownames(mtcars) #>  [1] \"Mazda RX4\"           \"Mazda RX4 Wag\"       \"Datsun 710\"          #>  [4] \"Hornet 4 Drive\"      \"Hornet Sportabout\"   \"Valiant\"             #>  [7] \"Duster 360\"          \"Merc 240D\"           \"Merc 230\"            #> [10] \"Merc 280\"            \"Merc 280C\"           \"Merc 450SE\"          #> [13] \"Merc 450SL\"          \"Merc 450SLC\"         \"Cadillac Fleetwood\"  #> [16] \"Lincoln Continental\" \"Chrysler Imperial\"   \"Fiat 128\"            #> [19] \"Honda Civic\"         \"Toyota Corolla\"      \"Toyota Corona\"       #> [22] \"Dodge Challenger\"    \"AMC Javelin\"         \"Camaro Z28\"          #> [25] \"Pontiac Firebird\"    \"Fiat X1-9\"           \"Porsche 914-2\"       #> [28] \"Lotus Europa\"        \"Ford Pantera L\"      \"Ferrari Dino\"        #> [31] \"Maserati Bora\"       \"Volvo 142E\"           # These getter functions are handy in conjunction with pluck() for # extracting deeply into a data structure. Here we'll first # extract by position, then by attribute: obj1 <- structure(\"obj\", obj_attr = \"foo\") obj2 <- structure(\"obj\", obj_attr = \"bar\") x <- list(obj1, obj2)  pluck(x, 1, attr_getter(\"obj_attr\"))  # From first object #> [1] \"foo\" pluck(x, 2, attr_getter(\"obj_attr\"))  # From second object #> [1] \"bar\""},{"path":"https://purrr.tidyverse.org/dev/reference/auto_browse.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrap a function so it will automatically browse() on error — auto_browse","title":"Wrap a function so it will automatically browse() on error — auto_browse","text":"function wrapped auto_browse() automatically enter interactive debugger using browser() ever encounters error.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/auto_browse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrap a function so it will automatically browse() on error — auto_browse","text":"","code":"auto_browse(.f)"},{"path":"https://purrr.tidyverse.org/dev/reference/auto_browse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrap a function so it will automatically browse() on error — auto_browse","text":".f function modify, specified one following ways: named function, e.g. mean. anonymous function, e.g. \\(x) x + 1 function(x) x + 1. formula, e.g. ~ .x + 1. recommended require backward compatibility older versions R.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/auto_browse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrap a function so it will automatically browse() on error — auto_browse","text":"function takes arguments .f, returns different value, described .","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/auto_browse.html","id":"adverbs","dir":"Reference","previous_headings":"","what":"Adverbs","title":"Wrap a function so it will automatically browse() on error — auto_browse","text":"function called adverb modifies effect function (verb). like include function created adverb package, sure read faq-adverbs-export.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/auto_browse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrap a function so it will automatically browse() on error — auto_browse","text":"","code":"# For interactive usage, auto_browse() is useful because it automatically # starts a browser() in the right place. f <- function(x) {   y <- 20   if (x > 5) {     stop(\"!\")   } else {     x   } } if (interactive()) {   map(1:6, auto_browse(f)) }"},{"path":"https://purrr.tidyverse.org/dev/reference/chuck.html","id":null,"dir":"Reference","previous_headings":"","what":"Get an element deep within a nested data structure, failing if it doesn't exist — chuck","title":"Get an element deep within a nested data structure, failing if it doesn't exist — chuck","text":"chuck() implements generalised form [[ allow index deeply flexibly data structures. index trying access exist (NULL), throw (.e. chuck) error.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/chuck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get an element deep within a nested data structure, failing if it doesn't exist — chuck","text":"","code":"chuck(.x, ...)"},{"path":"https://purrr.tidyverse.org/dev/reference/chuck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get an element deep within a nested data structure, failing if it doesn't exist — chuck","text":".x vector environment ... list accessors indexing object. Can positive integer, negative integer (index right), string (index names), accessor function (except assignment variants support names positions). object indexed S4 object, accessing name return corresponding slot. Dynamic dots supported. particular, accessors stored list, can splice !!!.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/chuck.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get an element deep within a nested data structure, failing if it doesn't exist — chuck","text":"","code":"x <- list(a = 1, b = 2)  # When indexing an element that doesn't exist `[[` sometimes returns NULL: x[[\"y\"]] #> NULL # and sometimes errors: try(x[[3]]) #> Error in x[[3]] : subscript out of bounds  # chuck() consistently errors: try(chuck(x, \"y\")) #> Error in chuck(x, \"y\") : Can't find name `y` in vector. try(chuck(x, 3)) #> Error in chuck(x, 3) :  #>   Index 1 exceeds the length of plucked object (3 > 2)."},{"path":"https://purrr.tidyverse.org/dev/reference/compose.html","id":null,"dir":"Reference","previous_headings":"","what":"Compose multiple functions together to create a new function — compose","title":"Compose multiple functions together to create a new function — compose","text":"Create new function composition multiple functions, .e. compose(f, g) equivalent function(...) f(g(...)).","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/compose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compose multiple functions together to create a new function — compose","text":"","code":"compose(..., .dir = c(\"backward\", \"forward\"))"},{"path":"https://purrr.tidyverse.org/dev/reference/compose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compose multiple functions together to create a new function — compose","text":"... Functions apply order (right left default). Formulas converted functions usual way. Dynamic dots supported. particular, functions stored list, can splice !!!. .dir \"backward\" (default), functions called reverse order, right left, conventional mathematics. \"forward\", called left right.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/compose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compose multiple functions together to create a new function — compose","text":"function","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/compose.html","id":"adverbs","dir":"Reference","previous_headings":"","what":"Adverbs","title":"Compose multiple functions together to create a new function — compose","text":"function called adverb modifies effect function (verb). like include function created adverb package, sure read faq-adverbs-export.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/compose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compose multiple functions together to create a new function — compose","text":"","code":"not_null <- compose(`!`, is.null) not_null(4) #> [1] TRUE not_null(NULL) #> [1] FALSE  add1 <- function(x) x + 1 compose(add1, add1)(8) #> [1] 10  fn <- compose(\\(x) paste(x, \"foo\"), \\(x) paste(x, \"bar\")) fn(\"input\") #> [1] \"input bar foo\"  # Lists of functions can be spliced with !!! fns <- list(   function(x) paste(x, \"foo\"),   \\(x) paste(x, \"bar\") ) fn <- compose(!!!fns) fn(\"input\") #> [1] \"input bar foo\""},{"path":"https://purrr.tidyverse.org/dev/reference/cross.html","id":null,"dir":"Reference","previous_headings":"","what":"Produce all combinations of list elements — cross","title":"Produce all combinations of list elements — cross","text":"functions deprecated purrr 1.0.0 slow buggy, longer think right approach solving problem. Please use tidyr::expand_grid() instead. example equivalent usages cross() expand_grid():","code":"data <- list(   id = c(\"John\", \"Jane\"),   sep = c(\"! \", \"... \"),   greeting = c(\"Hello.\", \"Bonjour.\") )  # With deprecated `cross()` data |> cross() |> map_chr(\\(...) paste0(..., collapse = \"\"))  # With `expand_grid()` tidyr::expand_grid(!!!data) |> pmap_chr(paste)"},{"path":"https://purrr.tidyverse.org/dev/reference/cross.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Produce all combinations of list elements — cross","text":"","code":"cross(.l, .filter = NULL)  cross2(.x, .y, .filter = NULL)  cross3(.x, .y, .z, .filter = NULL)  cross_df(.l, .filter = NULL)"},{"path":"https://purrr.tidyverse.org/dev/reference/cross.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Produce all combinations of list elements — cross","text":".l list lists atomic vectors. Alternatively, data frame. cross_df() requires elements named. .filter predicate function takes number arguments number variables combined. .x, .y, .z Lists atomic vectors.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/cross.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Produce all combinations of list elements — cross","text":"cross2(), cross3() cross() always return list. cross_df() always returns data frame. cross() returns list element one combination list can directly mapped . cross_df() returns data frame row one combination.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/cross.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Produce all combinations of list elements — cross","text":"cross2() returns product set elements .x .y. cross3() takes additional .z argument. cross() takes list .l returns cartesian product elements list, one combination element. cross_df() like cross() returns data frame, one combination row. cross(), cross2() cross3() return cartesian product returned wide format. makes amenable mapping operations. cross_df() returns output long format just expand.grid() . adapted rowwise operations. number combinations large individual elements heavy memory-wise, often useful filter unwanted combinations fly .filter. must predicate function takes number arguments number crossed objects (2 cross2(), 3 cross3(), length(.l) cross()) returns TRUE FALSE. combinations predicate function returns TRUE removed result.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/cross.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Produce all combinations of list elements — cross","text":"","code":"# We build all combinations of names, greetings and separators from our # list of data and pass each one to paste() data <- list(   id = c(\"John\", \"Jane\"),   greeting = c(\"Hello.\", \"Bonjour.\"),   sep = c(\"! \", \"... \") )  data |>   cross() |>   map(lift(paste)) #> Warning: `cross()` was deprecated in purrr 1.0.0. #> ℹ Please use `tidyr::expand_grid()` instead. #> ℹ See <https://github.com/tidyverse/purrr/issues/768>. #> Warning: `lift()` was deprecated in purrr 1.0.0. #> [[1]] #> [1] \"John! Hello.\" #>  #> [[2]] #> [1] \"Jane! Hello.\" #>  #> [[3]] #> [1] \"John! Bonjour.\" #>  #> [[4]] #> [1] \"Jane! Bonjour.\" #>  #> [[5]] #> [1] \"John... Hello.\" #>  #> [[6]] #> [1] \"Jane... Hello.\" #>  #> [[7]] #> [1] \"John... Bonjour.\" #>  #> [[8]] #> [1] \"Jane... Bonjour.\" #>   # cross() returns the combinations in long format: many elements, # each representing one combination. With cross_df() we'll get a # data frame in long format: crossing three objects produces a data # frame of three columns with each row being a particular # combination. This is the same format that expand.grid() returns. args <- data |> cross_df() #> Warning: `cross_df()` was deprecated in purrr 1.0.0. #> ℹ Please use `tidyr::expand_grid()` instead. #> ℹ See <https://github.com/tidyverse/purrr/issues/768>.  # In case you need a list in long format (and not a data frame) # just run as.list() after cross_df() args |> as.list() #> $id #> [1] \"John\" \"Jane\" \"John\" \"Jane\" \"John\" \"Jane\" \"John\" \"Jane\" #>  #> $greeting #> [1] \"Hello.\"   \"Hello.\"   \"Bonjour.\" \"Bonjour.\" \"Hello.\"   \"Hello.\"   #> [7] \"Bonjour.\" \"Bonjour.\" #>  #> $sep #> [1] \"! \"   \"! \"   \"! \"   \"! \"   \"... \" \"... \" \"... \" \"... \" #>   # This format is often less practical for functional programming # because applying a function to the combinations requires a loop out <- vector(\"character\", length = nrow(args)) for (i in seq_along(out))   out[[i]] <- invoke(\"paste\", map(args, i)) #> Warning: `invoke()` was deprecated in purrr 1.0.0. #> ℹ Please use `exec()` instead. out #> [1] \"John! Hello.\"     \"Jane! Hello.\"     \"John! Bonjour.\"   #> [4] \"Jane! Bonjour.\"   \"John... Hello.\"   \"Jane... Hello.\"   #> [7] \"John... Bonjour.\" \"Jane... Bonjour.\"  # It's easier to transpose and then use invoke_map() args |> transpose() |> map_chr(\\(x) exec(paste, !!!x)) #> [1] \"John! Hello.\"     \"Jane! Hello.\"     \"John! Bonjour.\"   #> [4] \"Jane! Bonjour.\"   \"John... Hello.\"   \"Jane... Hello.\"   #> [7] \"John... Bonjour.\" \"Jane... Bonjour.\"  # Unwanted combinations can be filtered out with a predicate function filter <- function(x, y) x >= y cross2(1:5, 1:5, .filter = filter) |> str() #> Warning: `cross2()` was deprecated in purrr 1.0.0. #> ℹ Please use `tidyr::expand_grid()` instead. #> ℹ See <https://github.com/tidyverse/purrr/issues/768>. #> List of 10 #>  $ :List of 2 #>   ..$ : int 1 #>   ..$ : int 2 #>  $ :List of 2 #>   ..$ : int 1 #>   ..$ : int 3 #>  $ :List of 2 #>   ..$ : int 2 #>   ..$ : int 3 #>  $ :List of 2 #>   ..$ : int 1 #>   ..$ : int 4 #>  $ :List of 2 #>   ..$ : int 2 #>   ..$ : int 4 #>  $ :List of 2 #>   ..$ : int 3 #>   ..$ : int 4 #>  $ :List of 2 #>   ..$ : int 1 #>   ..$ : int 5 #>  $ :List of 2 #>   ..$ : int 2 #>   ..$ : int 5 #>  $ :List of 2 #>   ..$ : int 3 #>   ..$ : int 5 #>  $ :List of 2 #>   ..$ : int 4 #>   ..$ : int 5  # To give names to the components of the combinations, we map # setNames() on the product: x <- seq_len(3) cross2(x, x, .filter = `==`) |>   map(setNames, c(\"x\", \"y\")) #> [[1]] #> [[1]]$x #> [1] 2 #>  #> [[1]]$y #> [1] 1 #>  #>  #> [[2]] #> [[2]]$x #> [1] 3 #>  #> [[2]]$y #> [1] 1 #>  #>  #> [[3]] #> [[3]]$x #> [1] 1 #>  #> [[3]]$y #> [1] 2 #>  #>  #> [[4]] #> [[4]]$x #> [1] 3 #>  #> [[4]]$y #> [1] 2 #>  #>  #> [[5]] #> [[5]]$x #> [1] 1 #>  #> [[5]]$y #> [1] 3 #>  #>  #> [[6]] #> [[6]]$x #> [1] 2 #>  #> [[6]]$y #> [1] 3 #>  #>   # Alternatively we can encapsulate the arguments in a named list # before crossing to get named components: list(x = x, y = x) |>   cross(.filter = `==`) #> [[1]] #> [[1]]$x #> [1] 2 #>  #> [[1]]$y #> [1] 1 #>  #>  #> [[2]] #> [[2]]$x #> [1] 3 #>  #> [[2]]$y #> [1] 1 #>  #>  #> [[3]] #> [[3]]$x #> [1] 1 #>  #> [[3]]$y #> [1] 2 #>  #>  #> [[4]] #> [[4]]$x #> [1] 3 #>  #> [[4]]$y #> [1] 2 #>  #>  #> [[5]] #> [[5]]$x #> [1] 1 #>  #> [[5]]$y #> [1] 3 #>  #>  #> [[6]] #> [[6]]$x #> [1] 2 #>  #> [[6]]$y #> [1] 3 #>  #>"},{"path":"https://purrr.tidyverse.org/dev/reference/detect.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the value or position of the first match — detect","title":"Find the value or position of the first match — detect","text":"Find value position first match","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/detect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the value or position of the first match — detect","text":"","code":"detect(.x, .f, ..., .dir = c(\"forward\", \"backward\"), .default = NULL)  detect_index(.x, .f, ..., .dir = c(\"forward\", \"backward\"))"},{"path":"https://purrr.tidyverse.org/dev/reference/detect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the value or position of the first match — detect","text":".x list vector. .f function, specified one following ways: named function, e.g. mean. anonymous function, e.g. \\(x) x + 1 function(x) x + 1. formula, e.g. ~ .x + 1. must use .x refer first argument. longer recommended. string, integer, list, e.g. \"idx\", 1, list(\"idx\", 1) shorthand \\(x) pluck(x, \"idx\"), \\(x) pluck(x, 1), \\(x) pluck(x, \"idx\", 1) respectively. Optionally supply .default set default value indexed element NULL exist. ... Additional arguments passed .p. .dir \"forward\", default, starts beginning vector move towards end; \"backward\", starts end vector moves towards beginning. .default value returned nothing detected.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/detect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the value or position of the first match — detect","text":"detect value first item matches predicate; detect_index position matching item. found, detect returns NULL detect_index returns 0.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/detect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the value or position of the first match — detect","text":"","code":"is_even <- function(x) x %% 2 == 0  3:10 |> detect(is_even) #> [1] 4 3:10 |> detect_index(is_even) #> [1] 2  3:10 |> detect(is_even, .dir = \"backward\") #> [1] 10 3:10 |> detect_index(is_even, .dir = \"backward\") #> [1] 8   # Since `.f` is passed to as_mapper(), you can supply a # lambda-formula or a pluck object: x <- list(   list(1, foo = FALSE),   list(2, foo = TRUE),   list(3, foo = TRUE) )  detect(x, \"foo\") #> [[1]] #> [1] 2 #>  #> $foo #> [1] TRUE #>  detect_index(x, \"foo\") #> [1] 2   # If you need to find all values, use keep(): keep(x, \"foo\") #> [[1]] #> [[1]][[1]] #> [1] 2 #>  #> [[1]]$foo #> [1] TRUE #>  #>  #> [[2]] #> [[2]][[1]] #> [1] 3 #>  #> [[2]]$foo #> [1] TRUE #>  #>   # If you need to find all positions, use map_lgl(): which(map_lgl(x, \"foo\")) #> [1] 2 3"},{"path":"https://purrr.tidyverse.org/dev/reference/every.html","id":null,"dir":"Reference","previous_headings":"","what":"Do every, some, or none of the elements of a list satisfy a predicate? — every","title":"Do every, some, or none of the elements of a list satisfy a predicate? — every","text":"() returns TRUE .p TRUE least one element. every() returns TRUE .p TRUE elements. none() returns TRUE .p FALSE elements.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/every.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do every, some, or none of the elements of a list satisfy a predicate? — every","text":"","code":"every(.x, .p, ...)  some(.x, .p, ...)  none(.x, .p, ...)"},{"path":"https://purrr.tidyverse.org/dev/reference/every.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do every, some, or none of the elements of a list satisfy a predicate? — every","text":".x list vector. .p predicate function (.e. function returns either TRUE FALSE) specified one following ways: named function, e.g. .character. anonymous function, e.g. \\(x) (x < 0) function(x) (x < 0). formula, e.g. ~ (.x < 0). must use .x refer first argument). longer recommended. ... Additional arguments passed .p.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/every.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do every, some, or none of the elements of a list satisfy a predicate? — every","text":"logical vector length 1.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/every.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do every, some, or none of the elements of a list satisfy a predicate? — every","text":"","code":"x <- list(0:10, 5.5) x |> every(is.numeric) #> [1] TRUE x |> every(is.integer) #> [1] FALSE x |> some(is.integer) #> [1] TRUE x |> none(is.character) #> [1] TRUE  # Missing values are propagated: some(list(NA, FALSE), identity) #> [1] NA  # If you need to use these functions in a context where missing values are # unsafe (e.g. in `if ()` conditions), make sure to use safe predicates: if (some(list(NA, FALSE), rlang::is_true)) \"foo\" else \"bar\" #> [1] \"bar\""},{"path":"https://purrr.tidyverse.org/dev/reference/faq-adverbs-export.html","id":null,"dir":"Reference","previous_headings":"","what":"Best practices for exporting adverb-wrapped functions — faq-adverbs-export","title":"Best practices for exporting adverb-wrapped functions — faq-adverbs-export","text":"Exporting functions created purrr adverbs package requires precautions functions contain internal purrr code. means creating package built may cause problems purrr updated, function adverb uses might longer exist. Instead, either create modified function per session package load wrap call within another function every time use : Using .onLoad() hook:   Using wrapper function:","code":"#' My function #' @export insist_my_function <- function(...) \"dummy\"  my_function <- function(...) {   # Implementation }  .onLoad <- function(lib, pkg) {   insist_my_function <<- purrr::insistently(my_function) } my_function <- function(...) {   # Implementation }  #' My function #' @export insist_my_function <- function(...) {   purrr::insistently(my_function)(...) }"},{"path":"https://purrr.tidyverse.org/dev/reference/flatten.html","id":null,"dir":"Reference","previous_headings":"","what":"Flatten a list of lists into a simple vector — flatten","title":"Flatten a list of lists into a simple vector — flatten","text":"functions superseded purrr 1.0.0 behaviour inconsistent. Superseded functions go away, receive critical bug fixes. flatten() superseded list_flatten(). flatten_lgl(), flatten_int(), flatten_dbl(), flatten_chr() superseded list_c(). flatten_dfr() flatten_dfc() superseded list_rbind() list_cbind() respectively.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/flatten.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flatten a list of lists into a simple vector — flatten","text":"","code":"flatten(.x)  flatten_lgl(.x)  flatten_int(.x)  flatten_dbl(.x)  flatten_chr(.x)  flatten_dfr(.x, .id = NULL)  flatten_dfc(.x)"},{"path":"https://purrr.tidyverse.org/dev/reference/flatten.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flatten a list of lists into a simple vector — flatten","text":".x list flatten. contents list can anything flatten() (list returned), contents must match type functions.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/flatten.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flatten a list of lists into a simple vector — flatten","text":"flatten() returns list, flatten_lgl() logical vector, flatten_int() integer vector, flatten_dbl() double vector, flatten_chr() character vector. flatten_dfr() flatten_dfc() return data frames created row-binding column-binding respectively. require dplyr installed.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/flatten.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flatten a list of lists into a simple vector — flatten","text":"","code":"x <- map(1:3, \\(i) sample(4)) x #> [[1]] #> [1] 2 1 4 3 #>  #> [[2]] #> [1] 4 2 1 3 #>  #> [[3]] #> [1] 2 4 1 3 #>   # was x |> flatten_int() |> str() #>  int [1:12] 2 1 4 3 4 2 1 3 2 4 ... # now x |> list_c() |> str() #>  int [1:12] 2 1 4 3 4 2 1 3 2 4 ...  x <- list(list(1, 2), list(3, 4)) # was x |> flatten() |> str() #> List of 4 #>  $ : num 1 #>  $ : num 2 #>  $ : num 3 #>  $ : num 4 # now x |> list_flatten() |> str() #> List of 4 #>  $ : num 1 #>  $ : num 2 #>  $ : num 3 #>  $ : num 4"},{"path":"https://purrr.tidyverse.org/dev/reference/has_element.html","id":null,"dir":"Reference","previous_headings":"","what":"Does a list contain an object? — has_element","title":"Does a list contain an object? — has_element","text":"list contain object?","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/has_element.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does a list contain an object? — has_element","text":"","code":"has_element(.x, .y)"},{"path":"https://purrr.tidyverse.org/dev/reference/has_element.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does a list contain an object? — has_element","text":".x list atomic vector. .y Object test ","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/has_element.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Does a list contain an object? — has_element","text":"","code":"x <- list(1:10, 5, 9.9) x |> has_element(1:10) #> [1] TRUE x |> has_element(3) #> [1] FALSE"},{"path":"https://purrr.tidyverse.org/dev/reference/head_while.html","id":null,"dir":"Reference","previous_headings":"","what":"Find head/tail that all satisfies a predicate. — head_while","title":"Find head/tail that all satisfies a predicate. — head_while","text":"Find head/tail satisfies predicate.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/head_while.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find head/tail that all satisfies a predicate. — head_while","text":"","code":"head_while(.x, .p, ...)  tail_while(.x, .p, ...)"},{"path":"https://purrr.tidyverse.org/dev/reference/head_while.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find head/tail that all satisfies a predicate. — head_while","text":".x list atomic vector. .p single predicate function, formula describing predicate function, logical vector length .x. Alternatively, elements .x lists objects, string indicating name logical element inner lists. elements .p evaluates TRUE modified. ... Additional arguments passed mapped function. now generally recommend using ... pass additional (constant) arguments .f. Instead use shorthand anonymous function:   makes easier understand arguments belong function tend yield better error messages.","code":"# Instead of x |> map(f, 1, 2, collapse = \",\") # do: x |> map(\\(x) f(x, 1, 2, collapse = \",\"))"},{"path":"https://purrr.tidyverse.org/dev/reference/head_while.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find head/tail that all satisfies a predicate. — head_while","text":"vector type .x.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/head_while.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find head/tail that all satisfies a predicate. — head_while","text":"","code":"pos <- function(x) x >= 0 head_while(5:-5, pos) #> [1] 5 4 3 2 1 0 tail_while(5:-5, negate(pos)) #> [1] -1 -2 -3 -4 -5  big <- function(x) x > 100 head_while(0:10, big) #> integer(0) tail_while(0:10, big) #> integer(0)"},{"path":"https://purrr.tidyverse.org/dev/reference/imap.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function to each element of a vector, and its index — imap","title":"Apply a function to each element of a vector, and its index — imap","text":"imap(x, ...), indexed map, short hand map2(x, names(x), ...) x names, map2(x, seq_along(x), ...) . useful need compute value position element.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/imap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function to each element of a vector, and its index — imap","text":"","code":"imap(.x, .f, ...)  imap_lgl(.x, .f, ...)  imap_chr(.x, .f, ...)  imap_int(.x, .f, ...)  imap_dbl(.x, .f, ...)  imap_vec(.x, .f, ...)  iwalk(.x, .f, ...)"},{"path":"https://purrr.tidyverse.org/dev/reference/imap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function to each element of a vector, and its index — imap","text":".x list atomic vector. .f function, specified one following ways: named function, e.g. paste. anonymous function, e.g. \\(x, idx) x + idx function(x, idx) x + idx. formula, e.g. ~ .x + .y. must use .x refer current element .y refer current index. longer recommended.  Wrap function in_parallel() declare performed parallel. See in_parallel() details. Use ... permitted context. ... Additional arguments passed mapped function. now generally recommend using ... pass additional (constant) arguments .f. Instead use shorthand anonymous function:   makes easier understand arguments belong function tend yield better error messages.","code":"# Instead of x |> map(f, 1, 2, collapse = \",\") # do: x |> map(\\(x) f(x, 1, 2, collapse = \",\"))"},{"path":"https://purrr.tidyverse.org/dev/reference/imap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function to each element of a vector, and its index — imap","text":"vector length .x.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/imap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function to each element of a vector, and its index — imap","text":"","code":"imap_chr(sample(10), paste) #>  [1] \"1 1\"  \"3 2\"  \"4 3\"  \"8 4\"  \"9 5\"  \"2 6\"  \"6 7\"  \"5 8\"  \"10 9\" #> [10] \"7 10\"  imap_chr(sample(10), \\(x, idx) paste0(idx, \": \", x)) #>  [1] \"1: 3\"  \"2: 6\"  \"3: 4\"  \"4: 2\"  \"5: 1\"  \"6: 10\" \"7: 9\"  \"8: 7\"  #>  [9] \"9: 5\"  \"10: 8\"  iwalk(mtcars, \\(x, idx) cat(idx, \": \", median(x), \"\\n\", sep = \"\")) #> mpg: 19.2 #> cyl: 6 #> disp: 196.3 #> hp: 123 #> drat: 3.695 #> wt: 3.325 #> qsec: 17.71 #> vs: 0 #> am: 0 #> gear: 4 #> carb: 2"},{"path":"https://purrr.tidyverse.org/dev/reference/in_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelization in purrr — in_parallel","title":"Parallelization in purrr — in_parallel","text":"map functions allow parallelized operation using mirai. Wrap functions passed .f argument map() variants in_parallel(). in_parallel() purrr adverb plays two roles: signal purrr verbs like map() go ahead perform computations parallel. helps create self-contained functions isolated workspace. important function packaged (serialized) sent across parallel processes. Isolation critical performance prevents accidentally sending large objects processes. maps actually performed parallel, user must also set mirai::daemons(), otherwise fall back sequential processing. mirai::require_daemons() may used enforce use parallel processing. See section 'Daemons settings' .","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/in_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelization in purrr — in_parallel","text":"","code":"in_parallel(.f, ...)"},{"path":"https://purrr.tidyverse.org/dev/reference/in_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelization in purrr — in_parallel","text":".f fresh formula function. \"Fresh\" means declared call in_parallel(). ... Named arguments declare environment function.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/in_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallelization in purrr — in_parallel","text":"'crate' (classed function).","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/in_parallel.html","id":"creating-self-contained-functions","dir":"Reference","previous_headings":"","what":"Creating self-contained functions","title":"Parallelization in purrr — in_parallel","text":"call package functions explicit :: namespace. instance ggplot() ggplot2 package must called namespace prefix: ggplot2::ggplot(). alternative use library() within function attach package search path, allows subsequent use package functions without explicit namespace. declare data depend . Declare data supplying named arguments .... .f anonymous function locally-defined function form \\(x) fun(x), fun must supplied ... manner : in_parallel(\\(x) fun(x), fun = fun). Additional arguments functions (closures) must self-contained. objects required must supplied additional arguments, already supplied. applies functions directly supplied ..., containers lists recursively walked find functions. means risk unexpectedly including large objects parallel function supply complex lists. in_parallel() simple wrapper carrier::crate() may refer package details. Example usage:","code":"# The function needs to be freshly-defined, so instead of: mtcars |> map_dbl(in_parallel(sum)) # Use an anonymous function: mtcars |> map_dbl(in_parallel(\\(x) sum(x)))  # Package functions need to be explicitly namespaced, so instead of: map(1:3, in_parallel(\\(x) vec_init(integer(), x))) # Use :: to namespace all package functions: map(1:3, in_parallel(\\(x) vctrs::vec_init(integer(), x)))  fun <- function(x) { x + helper_fun(x) } helper_fun <- function(x) { x %% 2 } # Operating in parallel, locally-defined objects will not be found. These # include objects required by your functions: map(1:3, in_parallel(\\(x) x + fun(x))) # Use the ... argument to supply these objects: map(1:3, in_parallel(\\(x) x + fun(x), fun = fun, helper_fun = helper_fun))"},{"path":"https://purrr.tidyverse.org/dev/reference/in_parallel.html","id":"when-to-use","dir":"Reference","previous_headings":"","what":"When to use","title":"Parallelization in purrr — in_parallel","text":"Parallelizing map using 'n' processes automatically lead taking 1/n time. Additional overhead setting parallel task communicating parallel processes eats benefit, can outweigh short tasks involving large amounts data. threshold parallelization becomes clearly beneficial differ according individual setup task, rough guide order 100 microseconds 1 millisecond map iteration.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/in_parallel.html","id":"daemons-settings","dir":"Reference","previous_headings":"","what":"Daemons settings","title":"Parallelization in purrr — in_parallel","text":"parallelization occurs determined mirai::daemons(). function mirai package sets daemons (persistent background processes receive parallel computations) local machine across network. Daemons must set prior performing parallel map operation, otherwise in_parallel() fall back sequential processing. ensure maps always performed parallel, put mirai::require_daemons() map. usual set daemons per session. can leave running local machine consume almost resources whilst waiting receive tasks. following sets 6 daemons locally:   Function arguments: n: number daemons launch local machine, e.g. mirai::daemons(6). rule thumb, maximum efficiency () one less number cores machine, leaving one core main R process. url remote: used set launch daemons distributed computing network. See mirai::daemons() documentation details. Resetting daemons: Daemons persist duration session. reset tear existing daemons:   daemons automatically terminate session ends. need explicitly terminate daemons instance, although still good practice . Note: always user set daemons. using parallel map within package, make mirai::daemons() calls within package, always user wish set parallel processing e.g. using local remote daemons. also helps prevent inadvertently spawning many daemons functions used recursively within .","code":"mirai::daemons(6) mirai::daemons(0)"},{"path":"https://purrr.tidyverse.org/dev/reference/in_parallel.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Parallelization in purrr — in_parallel","text":"purrr's parallelization powered mirai. See mirai website details.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/in_parallel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parallelization in purrr — in_parallel","text":"","code":"if (FALSE) { # interactive() && rlang::is_installed(\"mirai\") && rlang::is_installed(\"carrier\") # Run in interactive sessions only as spawns additional processes  delay <- function(secs = 0.5) {   Sys.sleep(secs) }  slow_lm <- function(formula, data) {   delay()   lm(formula, data) }  # Example of a 'crate' returned by in_parallel(). The object print method # shows the size of the crate and any objects contained within: crate <- in_parallel(   \\(df) slow_lm(mpg ~ disp, data = df),   slow_lm = slow_lm,   delay = delay ) crate  # Use mirai::mirai() to test that a crate is self-contained # by running it in a daemon and collecting its return value: mirai::mirai(crate(mtcars), crate = crate) |> mirai::collect_mirai() }"},{"path":"https://purrr.tidyverse.org/dev/reference/insistently.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a function to wait then retry after an error — insistently","title":"Transform a function to wait then retry after an error — insistently","text":"insistently() takes function modifies retry given amount time whenever errors.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/insistently.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a function to wait then retry after an error — insistently","text":"","code":"insistently(f, rate = rate_backoff(), quiet = TRUE)"},{"path":"https://purrr.tidyverse.org/dev/reference/insistently.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a function to wait then retry after an error — insistently","text":"f function modify, specified one following ways: named function, e.g. mean. anonymous function, e.g. \\(x) x + 1 function(x) x + 1. formula, e.g. ~ .x + 1. recommended require backward compatibility older versions R. rate rate object. Defaults jittered exponential backoff. quiet Hide errors (TRUE, default), display occur?","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/insistently.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a function to wait then retry after an error — insistently","text":"function takes arguments .f, returns different value, described .","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/insistently.html","id":"adverbs","dir":"Reference","previous_headings":"","what":"Adverbs","title":"Transform a function to wait then retry after an error — insistently","text":"function called adverb modifies effect function (verb). like include function created adverb package, sure read faq-adverbs-export.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/insistently.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform a function to wait then retry after an error — insistently","text":"","code":"# For the purpose of this example, we first create a custom rate # object with a low waiting time between attempts: rate <- rate_delay(0.1)  # insistently() makes a function repeatedly try to work risky_runif <- function(lo = 0, hi = 1) {   y <- runif(1, lo, hi)   if(y < 0.9) {     stop(y, \" is too small\")   }   y }  # Let's now create an exponential backoff rate with a low waiting # time between attempts: rate <- rate_backoff(pause_base = 0.1, pause_min = 0.005, max_times = 4)  # Modify your function to run insistently. insistent_risky_runif <- insistently(risky_runif, rate, quiet = FALSE)  set.seed(6) # Succeeding seed insistent_risky_runif() #> Error: 0.606268297648057 is too small #> Retrying in 0.19 seconds. #> Error: 0.264352067606524 is too small #> Retrying in 0.15 seconds. #> Error: 0.807483389042318 is too small #> Retrying in 0.78 seconds. #> [1] 0.9579337  set.seed(3) # Failing seed try(insistent_risky_runif()) #> Error: 0.168041526339948 is too small #> Retrying in 0.16 seconds. #> Error: 0.384942351374775 is too small #> Retrying in 0.13 seconds. #> Error: 0.602100674761459 is too small #> Retrying in 0.48 seconds. #> Error: 0.124633444240317 is too small #> Error in rate_sleep(rate, quiet = quiet) :  #>   Request failed after 4 attempts.  # You can also use other types of rate settings, like a delay rate # that waits for a fixed amount of time. Be aware that a delay rate # has an infinite amount of attempts by default: rate <- rate_delay(0.2, max_times = 3) insistent_risky_runif <- insistently(risky_runif, rate = rate, quiet = FALSE) try(insistent_risky_runif()) #> Error: 0.294600924244151 is too small #> Retrying in 0.2 seconds. #> Error: 0.577609919011593 is too small #> Retrying in 0.2 seconds. #> Error: 0.630979274399579 is too small #> Error in rate_sleep(rate, quiet = quiet) :  #>   Request failed after 3 attempts.  # insistently() and possibly() are a useful combination rate <- rate_backoff(pause_base = 0.1, pause_min = 0.005) possibly_insistent_risky_runif <- possibly(insistent_risky_runif, otherwise = -99)  set.seed(6) possibly_insistent_risky_runif() #> Error: 0.606268297648057 is too small #> Retrying in 0.2 seconds. #> [1] 0.937642  set.seed(3) possibly_insistent_risky_runif() #> Error: 0.168041526339948 is too small #> Retrying in 0.2 seconds. #> Error: 0.807516399072483 is too small #> Retrying in 0.2 seconds. #> Error: 0.384942351374775 is too small #> [1] -99"},{"path":"https://purrr.tidyverse.org/dev/reference/invoke.html","id":null,"dir":"Reference","previous_headings":"","what":"Invoke functions. — invoke","title":"Invoke functions. — invoke","text":"functions superded purrr 0.3.0 deprecated purrr 1.0.0. invoke() deprecated favour simpler exec() function reexported rlang. exec() evaluates function call built inputs supports dynamic dots:   invoke_map() deprecated harder understand corresponding code using map()/map2() exec():","code":"# Before: invoke(mean, list(na.rm = TRUE), x = 1:10)  # After exec(mean, 1:10, !!!list(na.rm = TRUE)) # Before: invoke_map(fns, list(args)) invoke_map(fns, list(args1, args2))  # After: map(fns, exec, !!!args) map2(fns, list(args1, args2), \\(fn, args) exec(fn, !!!args))"},{"path":"https://purrr.tidyverse.org/dev/reference/invoke.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Invoke functions. — invoke","text":"","code":"invoke(.f, .x = NULL, ..., .env = NULL)  invoke_map(.f, .x = list(NULL), ..., .env = NULL)  invoke_map_lgl(.f, .x = list(NULL), ..., .env = NULL)  invoke_map_int(.f, .x = list(NULL), ..., .env = NULL)  invoke_map_dbl(.f, .x = list(NULL), ..., .env = NULL)  invoke_map_chr(.f, .x = list(NULL), ..., .env = NULL)  invoke_map_raw(.f, .x = list(NULL), ..., .env = NULL)  invoke_map_dfr(.f, .x = list(NULL), ..., .env = NULL)  invoke_map_dfc(.f, .x = list(NULL), ..., .env = NULL)"},{"path":"https://purrr.tidyverse.org/dev/reference/invoke.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Invoke functions. — invoke","text":".f invoke, function; invoke_map list functions. .x invoke, argument-list; invoke_map list argument-lists length .f (length 1). default argument, list(NULL), recycled length .f, call function arguments (apart supplied .... ... Additional arguments passed function. .env Environment .call() evaluate constructed expression. matters pass .f name function rather value, .x symbols objects rather values.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/invoke.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Invoke functions. — invoke","text":"","code":"# was invoke(runif, list(n = 10)) #>  [1] 0.6043941 0.1246334 0.2946009 0.5776099 0.6309793 0.5120159 #>  [7] 0.5050239 0.5340354 0.5572494 0.8679195 invoke(runif, n = 10) #>  [1] 0.82970869 0.11144915 0.70368836 0.89748826 0.27973255 0.22820188 #>  [7] 0.01532989 0.12898156 0.09338193 0.23688501 # now exec(runif, n = 10) #>  [1] 0.7911474 0.5997316 0.9101477 0.5604246 0.7557048 0.3791719 #>  [7] 0.3732810 0.1702906 0.4533073 0.2584140  # was args <- list(\"01a\", \"01b\") invoke(paste, args, sep = \"-\") #> [1] \"01a-01b\" # now exec(paste, !!!args, sep = \"-\") #> [1] \"01a-01b\"  # was funs <- list(runif, rnorm) funs |> invoke_map(n = 5) #> Warning: `invoke_map()` was deprecated in purrr 1.0.0. #> ℹ Please use map() + exec() instead. #> [[1]] #> [1] 0.3362660 0.8895830 0.2019463 0.5791860 0.2076320 #>  #> [[2]] #> [1] -0.5784837 -0.9423007 -0.2037282 -1.6664748 -0.4844551 #>  funs |> invoke_map(list(list(n = 10), list(n = 5))) #> [[1]] #>  [1] 0.2293247 0.2129984 0.8771009 0.9932220 0.8442470 0.9104365 #>  [7] 0.4712697 0.2244184 0.1278147 0.2796835 #>  #> [[2]] #> [1]  0.9006247  0.8517704  0.7277152  0.7365021 -0.3521296 #>   # now funs |> map(exec, n = 5) #> [[1]] #> [1] 0.7597553 0.7608199 0.9032608 0.9662828 0.5152566 #>  #> [[2]] #> [1]  0.1243494 -0.9757388  0.6779977  0.3971048 -2.3838210 #>  funs |> map2(list(list(n = 10), list(n = 5)), function(f, args) exec(f, !!!args)) #> [[1]] #>  [1] 0.83861615 0.21342494 0.49471356 0.63624426 0.92109139 0.01174404 #>  [7] 0.26740292 0.43557210 0.82946709 0.87094404 #>  #> [[2]] #> [1] -0.6711297 -0.5065428  0.4676356  0.4736696  0.5590722 #>   # or use pmap + a tibble df <- tibble::tibble(   fun = list(runif, rnorm),   args = list(list(n = 10), list(n = 5)) ) df |> pmap(function(fun, args) exec(fun, !!!args)) #> [[1]] #>  [1] 0.34055921 0.04117032 0.40175251 0.07905965 0.31255265 0.32507594 #>  [7] 0.07836646 0.15021977 0.15242507 0.91342360 #>  #> [[2]] #> [1]  0.53089117  0.42769412 -0.09272151  0.92373577 -0.84181930 #>    # was list(m1 = mean, m2 = median) |> invoke_map(x = rcauchy(100)) #> $m1 #> [1] 1.982409 #>  #> $m2 #> [1] 0.1125127 #>  # now list(m1 = mean, m2 = median) |> map(function(f) f(rcauchy(100))) #> $m1 #> [1] -0.9786158 #>  #> $m2 #> [1] 0.1509643 #>"},{"path":"https://purrr.tidyverse.org/dev/reference/keep.html","id":null,"dir":"Reference","previous_headings":"","what":"Keep/discard elements based on their values — keep","title":"Keep/discard elements based on their values — keep","text":"keep() selects elements .p evaluates TRUE; discard() selects elements .p evaluates FALSE. compact() discards elements .p evaluates empty vector.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/keep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Keep/discard elements based on their values — keep","text":"","code":"keep(.x, .p, ...)  discard(.x, .p, ...)  compact(.x, .p = identity)"},{"path":"https://purrr.tidyverse.org/dev/reference/keep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Keep/discard elements based on their values — keep","text":".x list vector. .p predicate function (.e. function returns either TRUE FALSE) specified one following ways: named function, e.g. .character. anonymous function, e.g. \\(x) (x < 0) function(x) (x < 0). formula, e.g. ~ (.x < 0). must use .x refer first argument). longer recommended. ... Additional arguments passed .p.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/keep.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Keep/discard elements based on their values — keep","text":"languages, keep() discard() often called select()/ filter() reject()/ drop(), names already taken R. keep() similar Filter(), argument order convenient, evaluation predicate function .p stricter.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/keep.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Keep/discard elements based on their values — keep","text":"","code":"rep(10, 10) |>   map(sample, 5) |>   keep(function(x) mean(x) > 6) #> [[1]] #> [1]  8  6 10  3  9 #>  #> [[2]] #> [1] 6 7 9 5 8 #>  #> [[3]] #> [1] 9 8 5 2 7 #>   # Or use shorthand form rep(10, 10) |>   map(sample, 5) |>   keep(\\(x) mean(x) > 6) #> [[1]] #> [1] 10  9  6  4  7 #>  #> [[2]] #> [1]  8  2  7  5 10 #>   # Using a string instead of a function will select all list elements # where that subelement is TRUE x <- rerun(5, a = rbernoulli(1), b = sample(10)) #> Warning: `rerun()` was deprecated in purrr 1.0.0. #> ℹ Please use `map()` instead. #>   # Previously #>   rerun(5, a = rbernoulli(1), b = sample(10)) #>  #>   # Now #>   map(1:5, ~ list(a = rbernoulli(1), b = sample(10))) #> Warning: `rbernoulli()` was deprecated in purrr 1.0.0. x #> [[1]] #> [[1]]$a #> [1] TRUE #>  #> [[1]]$b #>  [1]  2  9  5  6  1  8  7  4  3 10 #>  #>  #> [[2]] #> [[2]]$a #> [1] FALSE #>  #> [[2]]$b #>  [1]  2 10  3  5  4  8  7  6  9  1 #>  #>  #> [[3]] #> [[3]]$a #> [1] TRUE #>  #> [[3]]$b #>  [1]  2  9  1  5  4  6  3  8  7 10 #>  #>  #> [[4]] #> [[4]]$a #> [1] FALSE #>  #> [[4]]$b #>  [1]  9  3  6  2  1  7  5  8 10  4 #>  #>  #> [[5]] #> [[5]]$a #> [1] TRUE #>  #> [[5]]$b #>  [1]  3  5  2  8  6  1  7 10  4  9 #>  #>  x |> keep(\"a\") #> [[1]] #> [[1]]$a #> [1] TRUE #>  #> [[1]]$b #>  [1]  2  9  5  6  1  8  7  4  3 10 #>  #>  #> [[2]] #> [[2]]$a #> [1] TRUE #>  #> [[2]]$b #>  [1]  2  9  1  5  4  6  3  8  7 10 #>  #>  #> [[3]] #> [[3]]$a #> [1] TRUE #>  #> [[3]]$b #>  [1]  3  5  2  8  6  1  7 10  4  9 #>  #>  x |> discard(\"a\") #> [[1]] #> [[1]]$a #> [1] FALSE #>  #> [[1]]$b #>  [1]  2 10  3  5  4  8  7  6  9  1 #>  #>  #> [[2]] #> [[2]]$a #> [1] FALSE #>  #> [[2]]$b #>  [1]  9  3  6  2  1  7  5  8 10  4 #>  #>   # compact() discards elements that are NULL or that have length zero list(a = \"a\", b = NULL, c = integer(0), d = NA, e = list()) |>   compact() #> $a #> [1] \"a\" #>  #> $d #> [1] NA #>"},{"path":"https://purrr.tidyverse.org/dev/reference/keep_at.html","id":null,"dir":"Reference","previous_headings":"","what":"Keep/discard elements based on their name/position — keep_at","title":"Keep/discard elements based on their name/position — keep_at","text":"Keep/discard elements based name/position","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/keep_at.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Keep/discard elements based on their name/position — keep_at","text":"","code":"keep_at(x, at)  discard_at(x, at)"},{"path":"https://purrr.tidyverse.org/dev/reference/keep_at.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Keep/discard elements based on their name/position — keep_at","text":"x list atomic vector. logical, integer, character vector giving elements select. Alternatively, function takes vector names, returns logical, integer, character vector elements select. : tidyselect package installed, can use vars() tidyselect helpers select elements.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/keep_at.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Keep/discard elements based on their name/position — keep_at","text":"","code":"x <- c(a = 1, b = 2, cat = 10, dog = 15, elephant = 5, e = 10) x |> keep_at(letters) #>  a  b  e  #>  1  2 10  x |> discard_at(letters) #>      cat      dog elephant  #>       10       15        5   # Can also use a function x |> keep_at(\\(x) nchar(x) == 3) #> cat dog  #>  10  15  x |> discard_at(\\(x) nchar(x) == 3) #>        a        b elephant        e  #>        1        2        5       10"},{"path":"https://purrr.tidyverse.org/dev/reference/lift.html","id":null,"dir":"Reference","previous_headings":"","what":"Lift the domain of a function — lift","title":"Lift the domain of a function — lift","text":"lift_xy() composition helper. helps compose functions lifting domain kind input another kind. domain can changed list (l), vector (v) dots (d). example, lift_ld(fun) transforms function taking list function taking dots. important helpers probably lift_dl() allows transform regular function one takes list. often essential composition purrr functional tools. Since common function, lift() provided alias operation. functions superseded purrr 1.0.0 longer believe \"lifting\" mainstream operation, striving reduce purrr useful core. Superseded functions go away, receive critical bug fixes.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/lift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lift the domain of a function — lift","text":"","code":"lift(..f, ..., .unnamed = FALSE)  lift_dl(..f, ..., .unnamed = FALSE)  lift_dv(..f, ..., .unnamed = FALSE)  lift_vl(..f, ..., .type)  lift_vd(..f, ..., .type)  lift_ld(..f, ...)  lift_lv(..f, ...)"},{"path":"https://purrr.tidyverse.org/dev/reference/lift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lift the domain of a function — lift","text":"..f function lift. ... Default arguments ..f. evaluated , lifting factory called. .unnamed TRUE, ld lv name parameters lifted function signature. prevents matching arguments name match position instead. .type Can vector mold specifying type length vectors concatenated, numeric(1) integer(4). Alternatively, can string describing type, one : \"logical\", \"integer\", \"double\", \"complex\", \"character\" \"raw\".","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/lift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lift the domain of a function — lift","text":"function.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/lift.html","id":"from-to-list-or-c-","dir":"Reference","previous_headings":"","what":"from ... to list(...) or c(...)","title":"Lift the domain of a function — lift","text":"dots taken figurative way. lifted functions need take dots per se. function simply wrapped function .call(), instead taking multiple arguments, takes single named list vector interpreted arguments.  particularly useful want pass row data frame list function want manually pull apart function.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/lift.html","id":"from-c-to-list-or-","dir":"Reference","previous_headings":"","what":"from c(...) to list(...) or ...","title":"Lift the domain of a function — lift","text":"factories allow function taking vector take list dots instead. lifted function internally transforms inputs back atomic vector. purrr obey usual R casting rules (e.g., c(1, \"2\") produces character vector) produce error types compatible. Additionally, can enforce particular vector type supplying .type.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/lift.html","id":"from-list-to-c-or-","dir":"Reference","previous_headings":"","what":"from list(...) to c(...) or ...","title":"Lift the domain of a function — lift","text":"lift_ld() turns function takes list function takes dots. lift_vd() function takes atomic vector. factory functions inverse operations lift_dl() lift_dv(). lift_vd() internally coerces inputs ..f atomic vector. details coercion can controlled .type.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/lift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lift the domain of a function — lift","text":"","code":"### Lifting from ... to list(...) or c(...)  x <- list(x = c(1:100, NA, 1000), na.rm = TRUE, trim = 0.9) lift_dl(mean)(x) #> [1] 51 # You can also use the lift() alias for this common operation: lift(mean)(x) #> [1] 51 # now: exec(mean, !!!x) #> [1] 51  # Default arguments can also be specified directly in lift_dl() list(c(1:100, NA, 1000)) |> lift_dl(mean, na.rm = TRUE)() #> [1] 59.90099 # now: mean(c(1:100, NA, 1000), na.rm = TRUE) #> [1] 59.90099  # lift_dl() and lift_ld() are inverse of each other. # Here we transform sum() so that it takes a list fun <- sum |> lift_dl() fun(list(3, NA, 4, na.rm = TRUE)) #> [1] 7 # now: fun <- function(x) exec(\"sum\", !!!x) exec(sum, 3, NA, 4, na.rm = TRUE) #> [1] 7 ### Lifting from c(...) to list(...) or ...  # In other situations we need the vector-valued function to take a # variable number of arguments as with pmap(). This is a job for # lift_vd(): pmap_dbl(mtcars, lift_vd(mean)) #> Warning: `lift_vd()` was deprecated in purrr 1.0.0. #>  [1] 29.90727 29.98136 23.59818 38.73955 53.66455 35.04909 59.72000 #>  [8] 24.63455 27.23364 31.86000 31.78727 46.43091 46.50000 46.35000 #> [15] 66.23273 66.05855 65.97227 19.44091 17.74227 18.81409 24.88864 #> [22] 47.24091 46.00773 58.75273 57.37955 18.92864 24.77909 24.88027 #> [29] 60.97182 34.50818 63.15545 26.26273 # now pmap_dbl(mtcars, \\(...) mean(c(...))) #>  [1] 29.90727 29.98136 23.59818 38.73955 53.66455 35.04909 59.72000 #>  [8] 24.63455 27.23364 31.86000 31.78727 46.43091 46.50000 46.35000 #> [15] 66.23273 66.05855 65.97227 19.44091 17.74227 18.81409 24.88864 #> [22] 47.24091 46.00773 58.75273 57.37955 18.92864 24.77909 24.88027 #> [29] 60.97182 34.50818 63.15545 26.26273 ### Lifting from list(...) to c(...) or ...  # This kind of lifting is sometimes needed for function # composition. An example would be to use pmap() with a function # that takes a list. In the following, we use some() on each row of # a data frame to check they each contain at least one element # satisfying a condition: mtcars |> pmap_lgl(lift_ld(some, partial(`<`, 200))) #> Warning: `lift_ld()` was deprecated in purrr 1.0.0. #>  [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE #> [12]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE #> [23]  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE # now mtcars |> pmap_lgl(\\(...) any(c(...) > 200)) #>  [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE #> [12]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE #> [23]  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE"},{"path":"https://purrr.tidyverse.org/dev/reference/list_assign.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify a list — list_assign","title":"Modify a list — list_assign","text":"list_assign() modifies elements list name position. list_modify() modifies elements list recursively. list_merge() merges elements list recursively. list_modify() inspired utils::modifyList().","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/list_assign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify a list — list_assign","text":"","code":"list_assign(.x, ..., .is_node = NULL)  list_modify(.x, ..., .is_node = NULL)  list_merge(.x, ..., .is_node = NULL)"},{"path":"https://purrr.tidyverse.org/dev/reference/list_assign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify a list — list_assign","text":".x List modify. ... New values list. Use zap() remove values. values either named unnamed. inputs named, matched .x name. unnamed, matched position. Dynamic dots supported. particular, replacement values stored list, can splice !!!. .is_node predicate function determines whether element node (returning TRUE) leaf (returning FALSE). default value, NULL, treats simple lists nodes everything else (including richer objects like data frames linear models) leaves, using vctrs::obj_is_list(). recurse objects built lists use .list().","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/list_assign.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modify a list — list_assign","text":"","code":"x <- list(x = 1:10, y = 4, z = list(a = 1, b = 2)) str(x) #> List of 3 #>  $ x: int [1:10] 1 2 3 4 5 6 7 8 9 10 #>  $ y: num 4 #>  $ z:List of 2 #>   ..$ a: num 1 #>   ..$ b: num 2  # Update values str(list_assign(x, a = 1)) #> List of 4 #>  $ x: int [1:10] 1 2 3 4 5 6 7 8 9 10 #>  $ y: num 4 #>  $ z:List of 2 #>   ..$ a: num 1 #>   ..$ b: num 2 #>  $ a: num 1  # Replace values str(list_assign(x, z = 5)) #> List of 3 #>  $ x: int [1:10] 1 2 3 4 5 6 7 8 9 10 #>  $ y: num 4 #>  $ z: num 5 str(list_assign(x, z = NULL)) #> List of 3 #>  $ x: int [1:10] 1 2 3 4 5 6 7 8 9 10 #>  $ y: num 4 #>  $ z: NULL str(list_assign(x, z = list(a = 1:5))) #> List of 3 #>  $ x: int [1:10] 1 2 3 4 5 6 7 8 9 10 #>  $ y: num 4 #>  $ z:List of 1 #>   ..$ a: int [1:5] 1 2 3 4 5  # Replace recursively with list_modify(), leaving the other elements of z alone str(list_modify(x, z = list(a = 1:5))) #> List of 3 #>  $ x: int [1:10] 1 2 3 4 5 6 7 8 9 10 #>  $ y: num 4 #>  $ z:List of 2 #>   ..$ a: int [1:5] 1 2 3 4 5 #>   ..$ b: num 2  # Remove values str(list_assign(x, z = zap())) #> List of 2 #>  $ x: int [1:10] 1 2 3 4 5 6 7 8 9 10 #>  $ y: num 4  # Combine values with list_merge() str(list_merge(x, x = 11, z = list(a = 2:5, c = 3))) #> List of 3 #>  $ x: num [1:11] 1 2 3 4 5 6 7 8 9 10 ... #>  $ y: num 4 #>  $ z:List of 3 #>   ..$ a: num [1:5] 1 2 3 4 5 #>   ..$ b: num 2 #>   ..$ c: num 3  # All these functions support dynamic dots features. Use !!! to splice # a list of arguments: l <- list(new = 1, y = zap(), z = 5) str(list_assign(x, !!!l)) #> List of 3 #>  $ x  : int [1:10] 1 2 3 4 5 6 7 8 9 10 #>  $ z  : num 5 #>  $ new: num 1"},{"path":"https://purrr.tidyverse.org/dev/reference/list_c.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine list elements into a single data structure — list_c","title":"Combine list elements into a single data structure — list_c","text":"list_c() combines elements vector concatenating together vctrs::vec_c(). list_rbind() combines elements data frame row-binding together vctrs::vec_rbind(). list_cbind() combines elements data frame column-binding together vctrs::vec_cbind().","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/list_c.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine list elements into a single data structure — list_c","text":"","code":"list_c(x, ..., ptype = NULL)  list_cbind(   x,   ...,   name_repair = c(\"unique\", \"universal\", \"check_unique\"),   size = NULL )  list_rbind(x, ..., names_to = rlang::zap(), ptype = NULL)"},{"path":"https://purrr.tidyverse.org/dev/reference/list_c.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine list elements into a single data structure — list_c","text":"x list. list_rbind() list_cbind() list must contain data frames NULL. ... dots future extensions must empty. ptype optional prototype ensure output type always . name_repair One \"unique\", \"universal\", \"check_unique\". See vctrs::vec_as_names() meaning options. size optional integer size ensure every input size (.e. number rows). names_to default, names(x) lost. keep , supply string names_to names saved column name. names_to supplied x named, position elements used instead names.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/list_c.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine list elements into a single data structure — list_c","text":"","code":"x1 <- list(a = 1, b = 2, c = 3) list_c(x1) #> [1] 1 2 3  x2 <- list(   a = data.frame(x = 1:2),   b = data.frame(y = \"a\") ) list_rbind(x2) #>    x    y #> 1  1 <NA> #> 2  2 <NA> #> 3 NA    a list_rbind(x2, names_to = \"id\") #>   id  x    y #> 1  a  1 <NA> #> 2  a  2 <NA> #> 3  b NA    a list_rbind(unname(x2), names_to = \"id\") #>   id  x    y #> 1  1  1 <NA> #> 2  1  2 <NA> #> 3  2 NA    a  list_cbind(x2) #>   x y #> 1 1 a #> 2 2 a"},{"path":"https://purrr.tidyverse.org/dev/reference/list_flatten.html","id":null,"dir":"Reference","previous_headings":"","what":"Flatten a list — list_flatten","title":"Flatten a list — list_flatten","text":"Flattening list removes single layer internal hierarchy, .e. inlines elements lists leaving non-lists alone.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/list_flatten.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flatten a list — list_flatten","text":"","code":"list_flatten(   x,   ...,   is_node = NULL,   name_spec = \"{outer}_{inner}\",   name_repair = c(\"minimal\", \"unique\", \"check_unique\", \"universal\") )"},{"path":"https://purrr.tidyverse.org/dev/reference/list_flatten.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flatten a list — list_flatten","text":"x list. ... dots future extensions must empty. is_node predicate function determines whether element node (returning TRUE) leaf (returning FALSE). default value, NULL, treats simple lists nodes everything else (including richer objects like data frames linear models) leaves, using vctrs::obj_is_list(). recurse objects built lists use .list(). name_spec inner outer names present, control combined. glue specification uses variables inner outer. name_repair One \"minimal\", \"unique\", \"universal\", \"check_unique\". See vctrs::vec_as_names() meaning options.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/list_flatten.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flatten a list — list_flatten","text":"list type x. list might shorter x contains empty lists, length contains lists length 1 sub-lists, longer contains lists length > 1.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/list_flatten.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flatten a list — list_flatten","text":"","code":"x <- list(1, list(2, 3), list(4, list(5))) x |> list_flatten() |> str() #> List of 5 #>  $ : num 1 #>  $ : num 2 #>  $ : num 3 #>  $ : num 4 #>  $ :List of 1 #>   ..$ : num 5 x |> list_flatten() |> list_flatten() |> str() #> List of 5 #>  $ : num 1 #>  $ : num 2 #>  $ : num 3 #>  $ : num 4 #>  $ : num 5  # Flat lists are left as is list(1, 2, 3, 4, 5) |> list_flatten() |> str() #> List of 5 #>  $ : num 1 #>  $ : num 2 #>  $ : num 3 #>  $ : num 4 #>  $ : num 5  # Empty lists will disappear list(1, list(), 2, list(3)) |> list_flatten() |> str() #> List of 3 #>  $ : num 1 #>  $ : num 2 #>  $ : num 3  # Another way to see this is that it reduces the depth of the list x <- list(   list(),   list(list()) ) x |> pluck_depth() #> [1] 3 x |> list_flatten() |> pluck_depth() #> [1] 2  # Use name_spec to control how inner and outer names are combined x <- list(x = list(a = 1, b = 2), y = list(c = 1, d = 2)) x |> list_flatten() |> names() #> [1] \"x_a\" \"x_b\" \"y_c\" \"y_d\" x |> list_flatten(name_spec = \"{outer}\") |> names() #> [1] \"x\" \"x\" \"y\" \"y\" x |> list_flatten(name_spec = \"{inner}\") |> names() #> [1] \"a\" \"b\" \"c\" \"d\"  # Set `is_node = is.list` to also flatten richer objects built on lists like # data frames and linear models df <- data.frame(x = 1:3, y = 4:6) x <- list(   a_string = \"something\",   a_list = list(1:3, \"else\"),   a_df = df ) x |> list_flatten(is_node = is.list) #> $a_string #> [1] \"something\" #>  #> $a_list_1 #> [1] 1 2 3 #>  #> $a_list_2 #> [1] \"else\" #>  #> $a_df_x #> [1] 1 2 3 #>  #> $a_df_y #> [1] 4 5 6 #>   # Note that objects that are already \"flat\" retain their classes list_flatten(df, is_node = is.list) #>   x y #> 1 1 4 #> 2 2 5 #> 3 3 6"},{"path":"https://purrr.tidyverse.org/dev/reference/list_simplify.html","id":null,"dir":"Reference","previous_headings":"","what":"Simplify a list to an atomic or S3 vector — list_simplify","title":"Simplify a list to an atomic or S3 vector — list_simplify","text":"Simplification maintains one--one correspondence input output, implying element x must contain one element vector one-row data frame. want maintain correspondence, probably want either list_c()/list_rbind() list_flatten().","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/list_simplify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simplify a list to an atomic or S3 vector — list_simplify","text":"","code":"list_simplify(x, ..., strict = TRUE, ptype = NULL)"},{"path":"https://purrr.tidyverse.org/dev/reference/list_simplify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simplify a list to an atomic or S3 vector — list_simplify","text":"x list. ... dots future extensions must empty. strict happen simplification fails? TRUE (default) error. FALSE ptype supplied, return x unchanged. ptype optional prototype ensure output type always .","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/list_simplify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simplify a list to an atomic or S3 vector — list_simplify","text":"vector length x.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/list_simplify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simplify a list to an atomic or S3 vector — list_simplify","text":"","code":"list_simplify(list(1, 2, 3)) #> [1] 1 2 3  # Only works when vectors are length one and have compatible types: try(list_simplify(list(1, 2, 1:3))) #> Error in list_simplify(list(1, 2, 1:3)) :  #>   `x[[3]]` must have size 1, not size 3. try(list_simplify(list(1, 2, \"x\"))) #> Error in list_simplify(list(1, 2, \"x\")) :  #>   Can't combine `<list>[[1]]` <double> and `<list>[[3]]` <character>.  # Unless you strict = FALSE, in which case you get the input back: list_simplify(list(1, 2, 1:3), strict = FALSE) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 1 2 3 #>  list_simplify(list(1, 2, \"x\"), strict = FALSE) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] \"x\" #>"},{"path":"https://purrr.tidyverse.org/dev/reference/list_transpose.html","id":null,"dir":"Reference","previous_headings":"","what":"Transpose a list — list_transpose","title":"Transpose a list — list_transpose","text":"list_transpose() turns list--lists \"inside-\". instance turns pair lists list pairs, list pairs pair lists. example, list length n component values b, list_transpose() make list elements b contained lists length n. called transpose x[[\"\"]][[\"b\"]] equivalent list_transpose(x)[[\"b\"]][[\"\"]], .e. transposing list flips order indices similar way transposing matrix.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/list_transpose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transpose a list — list_transpose","text":"","code":"list_transpose(   x,   ...,   template = NULL,   simplify = NA,   ptype = NULL,   default = NULL )"},{"path":"https://purrr.tidyverse.org/dev/reference/list_transpose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transpose a list — list_transpose","text":"x list vectors transpose. ... dots future extensions must empty. template \"template\" describes output list. Can either character vector (elements extracted name), integer vector (elements extracted position). Defaults union names elements x, present, union integer indices. simplify result simplified? TRUE: simplify die trying. NA: simplify possible. FALSE: never try simplify, always leaving list. Alternatively, named list specifying simplification output element. ptype optional vector prototype used control simplification. Alternatively, named list specifying prototype output element. default default value use value absent NULL. Alternatively, named list specifying default output element.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/list_transpose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transpose a list — list_transpose","text":"","code":"# list_transpose() is useful in conjunction with safely() x <- list(\"a\", 1, 2) y <- x |> map(safely(log)) y |> str() #> List of 3 #>  $ :List of 2 #>   ..$ result: NULL #>   ..$ error :List of 2 #>   .. ..$ message: chr \"non-numeric argument to mathematical function\" #>   .. ..$ call   : language .Primitive(\"log\")(x, base) #>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\" #>  $ :List of 2 #>   ..$ result: num 0 #>   ..$ error : NULL #>  $ :List of 2 #>   ..$ result: num 0.693 #>   ..$ error : NULL # Put all the errors and results together y |> list_transpose() |> str() #> List of 2 #>  $ result:List of 3 #>   ..$ : NULL #>   ..$ : num 0 #>   ..$ : num 0.693 #>  $ error :List of 3 #>   ..$ :List of 2 #>   .. ..$ message: chr \"non-numeric argument to mathematical function\" #>   .. ..$ call   : language .Primitive(\"log\")(x, base) #>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\" #>   ..$ : NULL #>   ..$ : NULL # Supply a default result to further simplify y |> list_transpose(default = list(result = NA)) |> str() #> List of 2 #>  $ result: num [1:3] NA 0 0.693 #>  $ error :List of 3 #>   ..$ :List of 2 #>   .. ..$ message: chr \"non-numeric argument to mathematical function\" #>   .. ..$ call   : language .Primitive(\"log\")(x, base) #>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\" #>   ..$ : NULL #>   ..$ : NULL  # list_transpose() will try to simplify by default: x <- list(list(a = 1, b = 2), list(a = 3, b = 4), list(a = 5, b = 6)) x |> list_transpose() #> $a #> [1] 1 3 5 #>  #> $b #> [1] 2 4 6 #>  # this makes list_tranpose() not completely symmetric x |> list_transpose() |> list_transpose() #> [[1]] #> a b  #> 1 2  #>  #> [[2]] #> a b  #> 3 4  #>  #> [[3]] #> a b  #> 5 6  #>   # use simplify = FALSE to always return lists: x |> list_transpose(simplify = FALSE) |> str() #> List of 2 #>  $ a:List of 3 #>   ..$ : num 1 #>   ..$ : num 3 #>   ..$ : num 5 #>  $ b:List of 3 #>   ..$ : num 2 #>   ..$ : num 4 #>   ..$ : num 6 x |>   list_transpose(simplify = FALSE) |>   list_transpose(simplify = FALSE) |> str() #> List of 3 #>  $ :List of 2 #>   ..$ a: num 1 #>   ..$ b: num 2 #>  $ :List of 2 #>   ..$ a: num 3 #>   ..$ b: num 4 #>  $ :List of 2 #>   ..$ a: num 5 #>   ..$ b: num 6  # Provide an explicit template if you know which elements you want to extract ll <- list(   list(x = 1, y = \"one\"),   list(z = \"deux\", x = 2) ) ll |> list_transpose() #> $x #> [1] 1 2 #>  #> $y #> $y[[1]] #> [1] \"one\" #>  #> $y[[2]] #> NULL #>  #>  #> $z #> $z[[1]] #> NULL #>  #> $z[[2]] #> [1] \"deux\" #>  #>  ll |> list_transpose(template = c(\"x\", \"y\", \"z\")) #> $x #> [1] 1 2 #>  #> $y #> $y[[1]] #> [1] \"one\" #>  #> $y[[2]] #> NULL #>  #>  #> $z #> $z[[1]] #> NULL #>  #> $z[[2]] #> [1] \"deux\" #>  #>  ll |> list_transpose(template = 1) #> [[1]] #> [[1]][[1]] #> [1] 1 #>  #> [[1]][[2]] #> [1] \"deux\" #>  #>   # And specify a default if you want to simplify ll |> list_transpose(template = c(\"x\", \"y\", \"z\"), default = NA) #> $x #> [1] 1 2 #>  #> $y #> [1] \"one\" NA    #>  #> $z #> [1] NA     \"deux\" #>"},{"path":"https://purrr.tidyverse.org/dev/reference/lmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function to list-elements of a list — lmap","title":"Apply a function to list-elements of a list — lmap","text":"lmap(), lmap_at() lmap_if() similar map(), map_at() map_if(), except instead mapping .x[[]], instead map .x[]. several advantages: makes possible work functions exclusively take list. allows .f access attributes encapsulating list, like names(). allows .f return larger small list receives changing size output.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/lmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function to list-elements of a list — lmap","text":"","code":"lmap(.x, .f, ...)  lmap_if(.x, .p, .f, ..., .else = NULL)  lmap_at(.x, .at, .f, ...)"},{"path":"https://purrr.tidyverse.org/dev/reference/lmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function to list-elements of a list — lmap","text":".x list data frame. .f function takes length-1 list returns list (length.) ... Additional arguments passed mapped function. now generally recommend using ... pass additional (constant) arguments .f. Instead use shorthand anonymous function:   makes easier understand arguments belong function tend yield better error messages. .p single predicate function, formula describing predicate function, logical vector length .x. Alternatively, elements .x lists objects, string indicating name logical element inner lists. elements .p evaluates TRUE modified. .else function applied elements .x .p returns FALSE. .logical, integer, character vector giving elements select. Alternatively, function takes vector names, returns logical, integer, character vector elements select. : tidyselect package installed, can use vars() tidyselect helpers select elements.","code":"# Instead of x |> map(f, 1, 2, collapse = \",\") # do: x |> map(\\(x) f(x, 1, 2, collapse = \",\"))"},{"path":"https://purrr.tidyverse.org/dev/reference/lmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function to list-elements of a list — lmap","text":"list data frame, matching .x. guarantees length.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/lmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function to list-elements of a list — lmap","text":"","code":"set.seed(1014)  # Let's write a function that returns a larger list or an empty list # depending on some condition. It also uses the input name to name the # output maybe_rep <- function(x) {   n <- rpois(1, 2)   set_names(rep_len(x, n), paste0(names(x), seq_len(n))) }  # The output size varies each time we map f() x <- list(a = 1:4, b = letters[5:7], c = 8:9, d = letters[10]) x |> lmap(maybe_rep) |> str() #> List of 6 #>  $ b1: chr [1:3] \"e\" \"f\" \"g\" #>  $ b2: chr [1:3] \"e\" \"f\" \"g\" #>  $ b3: chr [1:3] \"e\" \"f\" \"g\" #>  $ c1: int [1:2] 8 9 #>  $ c2: int [1:2] 8 9 #>  $ d1: chr \"j\"  # We can apply f() on a selected subset of x x |> lmap_at(c(\"a\", \"d\"), maybe_rep) |> str() #> List of 4 #>  $ b : chr [1:3] \"e\" \"f\" \"g\" #>  $ c : int [1:2] 8 9 #>  $ d1: chr \"j\" #>  $ d2: chr \"j\"  # Or only where a condition is satisfied x |> lmap_if(is.character, maybe_rep) |> str() #> List of 5 #>  $ a : int [1:4] 1 2 3 4 #>  $ b1: chr [1:3] \"e\" \"f\" \"g\" #>  $ b2: chr [1:3] \"e\" \"f\" \"g\" #>  $ c : int [1:2] 8 9 #>  $ d1: chr \"j\""},{"path":"https://purrr.tidyverse.org/dev/reference/map.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function to each element of a vector — map","title":"Apply a function to each element of a vector — map","text":"map functions transform input applying function element list atomic vector returning object length input. map() always returns list. See modify() family versions return object type input. map_lgl(), map_int(), map_dbl() map_chr() return atomic vector indicated type (die trying). functions, .f must return length-1 vector appropriate type. map_vec() simplifies common type output. works types simple vectors like Date, POSIXct, factors, etc. walk() calls .f side-effect returns input .x.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function to each element of a vector — map","text":"","code":"map(.x, .f, ..., .progress = FALSE)  map_lgl(.x, .f, ..., .progress = FALSE)  map_int(.x, .f, ..., .progress = FALSE)  map_dbl(.x, .f, ..., .progress = FALSE)  map_chr(.x, .f, ..., .progress = FALSE)  map_vec(.x, .f, ..., .ptype = NULL, .progress = FALSE)  walk(.x, .f, ..., .progress = FALSE)"},{"path":"https://purrr.tidyverse.org/dev/reference/map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function to each element of a vector — map","text":".x list atomic vector. .f function, specified one following ways: named function, e.g. mean. anonymous function, e.g. \\(x) x + 1 function(x) x + 1. formula, e.g. ~ .x + 1. must use .x refer first argument. longer recommended. string, integer, list, e.g. \"idx\", 1, list(\"idx\", 1) shorthand \\(x) pluck(x, \"idx\"), \\(x) pluck(x, 1), \\(x) pluck(x, \"idx\", 1) respectively. Optionally supply .default set default value indexed element NULL exist.  Wrap function in_parallel() declare performed parallel. See in_parallel() details. Use ... permitted context. ... Additional arguments passed mapped function. now generally recommend using ... pass additional (constant) arguments .f. Instead use shorthand anonymous function:   makes easier understand arguments belong function tend yield better error messages. .progress Whether show progress bar. Use TRUE turn basic progress bar, use string give name, see progress_bars details. .ptype NULL, default, output type common type elements result. Otherwise, supply \"prototype\" giving desired type output.","code":"# Instead of x |> map(f, 1, 2, collapse = \",\") # do: x |> map(\\(x) f(x, 1, 2, collapse = \",\"))"},{"path":"https://purrr.tidyverse.org/dev/reference/map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function to each element of a vector — map","text":"output length determined length input. output names determined input names. output type determined suffix: suffix: list; .f() can return anything. _lgl(), _int(), _dbl(), _chr() return logical, integer, double, character vector respectively; .f() must return compatible atomic vector length 1. _vec() return atomic S3 vector, type .f returns. .f can return pretty much type vector, long length 1. walk() returns input .x (invisibly). makes easy use pipe. return value .f() ignored. errors thrown .f wrapped error class purrr_error_indexed.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function to each element of a vector — map","text":"","code":"# Compute normal distributions from an atomic vector 1:10 |>   map(rnorm, n = 10) #> [[1]] #>  [1]  2.1484116 -0.8218177  0.7526747  0.7558004  0.7172946  0.4463006 #>  [7]  1.6289820  3.0650249 -0.6309894  1.5124269 #>  #> [[2]] #>  [1] 0.1369885 1.4779875 1.9473981 2.5429963 1.0859252 2.4681544 #>  [7] 2.3629513 0.6954565 2.7377763 3.8885049 #>  #> [[3]] #>  [1] 2.902555 2.064153 2.984050 2.173211 1.487600 3.935363 3.176489 #>  [8] 3.243685 4.623549 3.112038 #>  #> [[4]] #>  [1] 3.866003 2.089913 3.720763 3.686554 5.067308 4.070035 3.360877 #>  [8] 3.950035 3.748517 4.444797 #>  #> [[5]] #>  [1] 7.755418 5.046531 5.577709 5.118195 3.088280 5.862086 4.756763 #>  [8] 4.793913 5.019178 5.029561 #>  #> [[6]] #>  [1] 6.549828 3.725885 8.682557 5.638779 6.213356 7.074346 5.334912 #>  [8] 7.113952 5.754104 4.822437 #>  #> [[7]] #>  [1] 6.024149 8.065057 7.131671 7.488629 5.300549 5.529264 7.284150 #>  [8] 8.337320 7.236696 8.318293 #>  #> [[8]] #>  [1] 8.523910 8.606748 7.890064 8.172182 7.909673 9.924343 9.298393 #>  [8] 8.748791 8.556224 7.451743 #>  #> [[9]] #>  [1] 10.110535  6.387666  8.844306  9.433890  8.618049  9.424188 #>  [7] 10.063102 10.048713  8.961897  9.486149 #>  #> [[10]] #>  [1] 11.672883  9.645639 10.946348 11.316826  9.703360  9.612786 #>  [7]  9.214567  8.943263  9.204459  8.243725 #>   # You can also use an anonymous function 1:10 |>   map(\\(x) rnorm(10, x)) #> [[1]] #>  [1]  0.3094621  0.4414580  0.4633367  1.2271271  1.9784549  0.7911173 #>  [7] -0.3994105  1.2585373  0.5582005  1.5685999 #>  #> [[2]] #>  [1] 4.1268505 2.4248584 0.3157185 2.2494018 3.0728383 4.0393693 #>  [7] 2.4494538 3.3918140 2.4265665 2.1075840 #>  #> [[3]] #>  [1] 3.022295 3.603611 2.737349 2.471736 3.192149 1.853800 3.846185 #>  [8] 3.081720 1.694883 2.055088 #>  #> [[4]] #>  [1] 4.454342 3.144797 3.713105 4.894962 4.067304 3.837324 3.172690 #>  [8] 5.876506 4.766440 4.979957 #>  #> [[5]] #>  [1] 6.321781 3.880289 5.514600 3.490900 6.532741 5.429147 5.122103 #>  [8] 3.861988 4.441985 6.052539 #>  #> [[6]] #>  [1] 6.677684 6.038500 5.643619 6.782844 6.804412 4.099939 6.935784 #>  [8] 5.690948 6.263067 4.209408 #>  #> [[7]] #>  [1] 6.211741 5.866978 7.363653 6.714112 7.517669 6.897091 6.025930 #>  [8] 8.270672 7.960865 7.768721 #>  #> [[8]] #>  [1]  9.035931  7.526113  6.724665  7.694379 10.211769  6.958332 #>  [7]  6.853476  6.324673  9.525939  8.554186 #>  #> [[9]] #>  [1] 10.993110  8.845879 11.564408 10.061999 10.142695 10.123839 #>  [7]  8.602999  8.176739  8.421115 10.763789 #>  #> [[10]] #>  [1] 10.132992 10.376499 11.138708 11.241263 10.612091  9.570620 #>  [7] 11.360461  9.929143  9.727846  7.553320 #>   # Simplify output to a vector instead of a list by computing the mean of the distributions 1:10 |>   map(rnorm, n = 10) |>  # output a list   map_dbl(mean)           # output an atomic vector #>  [1]  0.7483032  1.9289496  2.8461081  3.9944891  5.0055171  5.7423877 #>  [7]  6.6846082  8.6550474  9.2117627 10.1718634  # Using set_names() with character vectors is handy to keep track # of the original inputs: set_names(c(\"foo\", \"bar\")) |> map_chr(paste0, \":suffix\") #>          foo          bar  #> \"foo:suffix\" \"bar:suffix\"   # Working with lists favorite_desserts <- list(Sophia = \"banana bread\", Eliott = \"pancakes\", Karina = \"chocolate cake\") favorite_desserts |> map_chr(\\(food) paste(food, \"rocks!\")) #>                  Sophia                  Eliott  #>   \"banana bread rocks!\"       \"pancakes rocks!\"  #>                  Karina  #> \"chocolate cake rocks!\"   # Extract by name or position # .default specifies value for elements that are missing or NULL l1 <- list(list(a = 1L), list(a = NULL, b = 2L), list(b = 3L)) l1 |> map(\"a\", .default = \"???\") #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] \"???\" #>  #> [[3]] #> [1] \"???\" #>  l1 |> map_int(\"b\", .default = NA) #> [1] NA  2  3 l1 |> map_int(2, .default = NA) #> [1] NA  2 NA  # Supply multiple values to index deeply into a list l2 <- list(   list(num = 1:3,     letters[1:3]),   list(num = 101:103, letters[4:6]),   list() ) l2 |> map(c(2, 2)) #> [[1]] #> [1] \"b\" #>  #> [[2]] #> [1] \"e\" #>  #> [[3]] #> NULL #>   # Use a list to build an extractor that mixes numeric indices and names, # and .default to provide a default value if the element does not exist l2 |> map(list(\"num\", 3)) #> [[1]] #> [1] 3 #>  #> [[2]] #> [1] 103 #>  #> [[3]] #> NULL #>  l2 |> map_int(list(\"num\", 3), .default = NA) #> [1]   3 103  NA  # Working with data frames # Use map_lgl(), map_dbl(), etc to return a vector instead of a list: mtcars |> map_dbl(sum) #>      mpg      cyl     disp       hp     drat       wt     qsec  #>  642.900  198.000 7383.100 4694.000  115.090  102.952  571.160  #>       vs       am     gear     carb  #>   14.000   13.000  118.000   90.000   # A more realistic example: split a data frame into pieces, fit a # model to each piece, summarise and extract R^2 mtcars |>   split(mtcars$cyl) |>   map(\\(df) lm(mpg ~ wt, data = df)) |>   map(summary) |>   map_dbl(\"r.squared\") #>         4         6         8  #> 0.5086326 0.4645102 0.4229655   if (FALSE) { # interactive() && rlang::is_installed(\"mirai\") && rlang::is_installed(\"carrier\") # Run in interactive sessions only as spawns additional processes  # To use parallelized map: # 1. Set daemons (number of parallel processes) first: mirai::daemons(2)  # 2. Wrap .f with in_parallel(): mtcars |> map_dbl(in_parallel(\\(x) mean(x)))  # Note that functions from packages should be fully qualified with `pkg::` # or call `library(pkg)` within the function 1:10 |>   map(in_parallel(\\(x) vctrs::vec_init(integer(), x))) |>   map_int(in_parallel(\\(x) { library(vctrs); vec_size(x) }))  # A locally-defined function (or any required variables) # should be passed via ... of in_parallel(): slow_lm <- function(formula, data) {   Sys.sleep(0.5)   lm(formula, data) }  mtcars |>   split(mtcars$cyl) |>   map(in_parallel(\\(df) slow_lm(mpg ~ disp, data = df), slow_lm = slow_lm))  # Tear down daemons when no longer in use: mirai::daemons(0) }"},{"path":"https://purrr.tidyverse.org/dev/reference/map2.html","id":null,"dir":"Reference","previous_headings":"","what":"Map over two inputs — map2","title":"Map over two inputs — map2","text":"functions variants map() iterate two arguments time.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/map2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map over two inputs — map2","text":"","code":"map2(.x, .y, .f, ..., .progress = FALSE)  map2_lgl(.x, .y, .f, ..., .progress = FALSE)  map2_int(.x, .y, .f, ..., .progress = FALSE)  map2_dbl(.x, .y, .f, ..., .progress = FALSE)  map2_chr(.x, .y, .f, ..., .progress = FALSE)  map2_vec(.x, .y, .f, ..., .ptype = NULL, .progress = FALSE)  walk2(.x, .y, .f, ..., .progress = FALSE)"},{"path":"https://purrr.tidyverse.org/dev/reference/map2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map over two inputs — map2","text":".x, .y pair vectors, usually length. , vector length 1 recycled length . .f function, specified one following ways: named function. anonymous function, e.g. \\(x, y) x + y function(x, y) x + y. formula, e.g. ~ .x + .y. must use .x refer current element x .y refer current element y. longer recommended.  Wrap function in_parallel() declare performed parallel. See in_parallel() details. Use ... permitted context. ... Additional arguments passed mapped function. now generally recommend using ... pass additional (constant) arguments .f. Instead use shorthand anonymous function:   makes easier understand arguments belong function tend yield better error messages. .progress Whether show progress bar. Use TRUE turn basic progress bar, use string give name, see progress_bars details. .ptype NULL, default, output type common type elements result. Otherwise, supply \"prototype\" giving desired type output.","code":"# Instead of x |> map(f, 1, 2, collapse = \",\") # do: x |> map(\\(x) f(x, 1, 2, collapse = \",\"))"},{"path":"https://purrr.tidyverse.org/dev/reference/map2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map over two inputs — map2","text":"output length determined length input. output names determined input names. output type determined suffix: suffix: list; .f() can return anything. _lgl(), _int(), _dbl(), _chr() return logical, integer, double, character vector respectively; .f() must return compatible atomic vector length 1. _vec() return atomic S3 vector, type .f returns. .f can return pretty much type vector, long length 1. walk() returns input .x (invisibly). makes easy use pipe. return value .f() ignored. errors thrown .f wrapped error class purrr_error_indexed.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/map2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map over two inputs — map2","text":"","code":"x <- list(1, 1, 1) y <- list(10, 20, 30)  map2(x, y, \\(x, y) x + y) #> [[1]] #> [1] 11 #>  #> [[2]] #> [1] 21 #>  #> [[3]] #> [1] 31 #>  # Or just map2(x, y, `+`) #> [[1]] #> [1] 11 #>  #> [[2]] #> [1] 21 #>  #> [[3]] #> [1] 31 #>   # Split into pieces, fit model to each piece, then predict by_cyl <- mtcars |> split(mtcars$cyl) mods <- by_cyl |> map(\\(df) lm(mpg ~ wt, data = df)) map2(mods, by_cyl, predict) #> $`4` #>     Datsun 710      Merc 240D       Merc 230       Fiat 128  #>       26.47010       21.55719       21.78307       27.14774  #>    Honda Civic Toyota Corolla  Toyota Corona      Fiat X1-9  #>       30.45125       29.20890       25.65128       28.64420  #>  Porsche 914-2   Lotus Europa     Volvo 142E  #>       27.48656       31.02725       23.87247  #>  #> $`6` #>      Mazda RX4  Mazda RX4 Wag Hornet 4 Drive        Valiant  #>       21.12497       20.41604       19.47080       18.78968  #>       Merc 280      Merc 280C   Ferrari Dino  #>       18.84528       18.84528       20.70795  #>  #> $`8` #>   Hornet Sportabout          Duster 360          Merc 450SE  #>            16.32604            16.04103            14.94481  #>          Merc 450SL         Merc 450SLC  Cadillac Fleetwood  #>            15.69024            15.58061            12.35773  #> Lincoln Continental   Chrysler Imperial    Dodge Challenger  #>            11.97625            12.14945            16.15065  #>         AMC Javelin          Camaro Z28    Pontiac Firebird  #>            16.33700            15.44907            15.43811  #>      Ford Pantera L       Maserati Bora  #>            16.91800            16.04103  #>"},{"path":"https://purrr.tidyverse.org/dev/reference/map_depth.html","id":null,"dir":"Reference","previous_headings":"","what":"Map/modify elements at given depth — map_depth","title":"Map/modify elements at given depth — map_depth","text":"map_depth() calls map(.y, .f) .y specified .depth .x. modify_depth() calls modify(.y, .f) .y specified .depth .x.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/map_depth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map/modify elements at given depth — map_depth","text":"","code":"map_depth(.x, .depth, .f, ..., .ragged = .depth < 0, .is_node = NULL)  modify_depth(.x, .depth, .f, ..., .ragged = .depth < 0, .is_node = NULL)"},{"path":"https://purrr.tidyverse.org/dev/reference/map_depth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map/modify elements at given depth — map_depth","text":".x list atomic vector. .depth Level .x map . Use negative value count lowest level list. map_depth(x, 0, fun) equivalent fun(x). map_depth(x, 1, fun) equivalent x <- map(x, fun) map_depth(x, 2, fun) equivalent x <- map(x, \\(y) map(y, fun)) .f function, specified one following ways: named function, e.g. mean. anonymous function, e.g. \\(x) x + 1 function(x) x + 1. formula, e.g. ~ .x + 1. must use .x refer first argument. longer recommended. string, integer, list, e.g. \"idx\", 1, list(\"idx\", 1) shorthand \\(x) pluck(x, \"idx\"), \\(x) pluck(x, 1), \\(x) pluck(x, \"idx\", 1) respectively. Optionally supply .default set default value indexed element NULL exist.  Wrap function in_parallel() declare performed parallel. See in_parallel() details. Use ... permitted context. ... Additional arguments passed mapped function. now generally recommend using ... pass additional (constant) arguments .f. Instead use shorthand anonymous function:   makes easier understand arguments belong function tend yield better error messages. .ragged TRUE, apply leaves, even depth .depth. FALSE, throw error elements depth .depth. .is_node predicate function determines whether element node (returning TRUE) leaf (returning FALSE). default value, NULL, treats simple lists nodes everything else (including richer objects like data frames linear models) leaves, using vctrs::obj_is_list(). recurse objects built lists use .list().","code":"# Instead of x |> map(f, 1, 2, collapse = \",\") # do: x |> map(\\(x) f(x, 1, 2, collapse = \",\"))"},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/map_depth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map/modify elements at given depth — map_depth","text":"","code":"# map_depth() ------------------------------------------------- # Use `map_depth()` to recursively traverse nested vectors and map # a function at a certain depth: x <- list(a = list(foo = 1:2, bar = 3:4), b = list(baz = 5:6)) x |> str() #> List of 2 #>  $ a:List of 2 #>   ..$ foo: int [1:2] 1 2 #>   ..$ bar: int [1:2] 3 4 #>  $ b:List of 1 #>   ..$ baz: int [1:2] 5 6 x |> map_depth(2, \\(y) paste(y, collapse = \"/\")) |> str() #> List of 2 #>  $ a:List of 2 #>   ..$ foo: chr \"1/2\" #>   ..$ bar: chr \"3/4\" #>  $ b:List of 1 #>   ..$ baz: chr \"5/6\"  # Equivalent to: x |> map(\\(y) map(y, \\(z) paste(z, collapse = \"/\"))) |> str() #> List of 2 #>  $ a:List of 2 #>   ..$ foo: chr \"1/2\" #>   ..$ bar: chr \"3/4\" #>  $ b:List of 1 #>   ..$ baz: chr \"5/6\"  # When ragged is TRUE, `.f()` will also be passed leaves at depth < `.depth` x <- list(1, list(1, list(1, list(1, 1)))) x |> str() #> List of 2 #>  $ : num 1 #>  $ :List of 2 #>   ..$ : num 1 #>   ..$ :List of 2 #>   .. ..$ : num 1 #>   .. ..$ :List of 2 #>   .. .. ..$ : num 1 #>   .. .. ..$ : num 1 x |> map_depth(4, \\(x) length(unlist(x)), .ragged = TRUE) |> str() #> List of 2 #>  $ :List of 1 #>   ..$ : int 1 #>  $ :List of 2 #>   ..$ :List of 1 #>   .. ..$ : int 1 #>   ..$ :List of 2 #>   .. ..$ :List of 1 #>   .. .. ..$ : int 1 #>   .. ..$ :List of 2 #>   .. .. ..$ : int 1 #>   .. .. ..$ : int 1 x |> map_depth(3, \\(x) length(unlist(x)), .ragged = TRUE) |> str() #> List of 2 #>  $ :List of 1 #>   ..$ : int 1 #>  $ :List of 2 #>   ..$ :List of 1 #>   .. ..$ : int 1 #>   ..$ :List of 2 #>   .. ..$ : int 1 #>   .. ..$ : int 2 x |> map_depth(2, \\(x) length(unlist(x)), .ragged = TRUE) |> str() #> List of 2 #>  $ :List of 1 #>   ..$ : int 1 #>  $ :List of 2 #>   ..$ : int 1 #>   ..$ : int 3 x |> map_depth(1, \\(x) length(unlist(x)), .ragged = TRUE) |> str() #> List of 2 #>  $ : int 1 #>  $ : int 4 x |> map_depth(0, \\(x) length(unlist(x)), .ragged = TRUE) |> str() #>  int 5  # modify_depth() ------------------------------------------------- l1 <- list(   obj1 = list(     prop1 = list(param1 = 1:2, param2 = 3:4),     prop2 = list(param1 = 5:6, param2 = 7:8)   ),   obj2 = list(     prop1 = list(param1 = 9:10, param2 = 11:12),     prop2 = list(param1 = 12:14, param2 = 15:17)   ) )  # In the above list, \"obj\" is level 1, \"prop\" is level 2 and \"param\" # is level 3. To apply sum() on all params, we map it at depth 3: l1 |> modify_depth(3, sum) |> str() #> List of 2 #>  $ obj1:List of 2 #>   ..$ prop1:List of 2 #>   .. ..$ param1: int 3 #>   .. ..$ param2: int 7 #>   ..$ prop2:List of 2 #>   .. ..$ param1: int 11 #>   .. ..$ param2: int 15 #>  $ obj2:List of 2 #>   ..$ prop1:List of 2 #>   .. ..$ param1: int 19 #>   .. ..$ param2: int 23 #>   ..$ prop2:List of 2 #>   .. ..$ param1: int 39 #>   .. ..$ param2: int 48  # modify() lets us pluck the elements prop1/param2 in obj1 and obj2: l1 |> modify(c(\"prop1\", \"param2\")) |> str() #> List of 2 #>  $ obj1: int [1:2] 3 4 #>  $ obj2: int [1:2] 11 12  # But what if we want to pluck all param2 elements? Then we need to # act at a lower level: l1 |> modify_depth(2, \"param2\") |> str() #> List of 2 #>  $ obj1:List of 2 #>   ..$ prop1: int [1:2] 3 4 #>   ..$ prop2: int [1:2] 7 8 #>  $ obj2:List of 2 #>   ..$ prop1: int [1:2] 11 12 #>   ..$ prop2: int [1:3] 15 16 17  # modify_depth() can be with other purrr functions to make them operate at # a lower level. Here we ask pmap() to map paste() simultaneously over all # elements of the objects at the second level. paste() is effectively # mapped at level 3. l1 |> modify_depth(2, \\(x) pmap(x, paste, sep = \" / \")) |> str() #> List of 2 #>  $ obj1:List of 2 #>   ..$ prop1:List of 2 #>   .. ..$ : chr \"1 / 3\" #>   .. ..$ : chr \"2 / 4\" #>   ..$ prop2:List of 2 #>   .. ..$ : chr \"5 / 7\" #>   .. ..$ : chr \"6 / 8\" #>  $ obj2:List of 2 #>   ..$ prop1:List of 2 #>   .. ..$ : chr \"9 / 11\" #>   .. ..$ : chr \"10 / 12\" #>   ..$ prop2:List of 3 #>   .. ..$ : chr \"12 / 15\" #>   .. ..$ : chr \"13 / 16\" #>   .. ..$ : chr \"14 / 17\""},{"path":"https://purrr.tidyverse.org/dev/reference/map_dfr.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions that return data frames — map_dfr","title":"Functions that return data frames — map_dfr","text":"map(), map2(), imap(), pmap() variants return data frames row-binding column-binding outputs together. functions superseded purrr 1.0.0 names suggest work like _lgl(), _int(), etc require length 1 outputs, actually return results size results combined without size checks. Additionally, use dplyr::bind_rows() dplyr::bind_cols() require dplyr installed confusing semantics edge cases. Superseded functions go away, receive critical bug fixes. Instead, recommend using map(), map2(), etc list_rbind() list_cbind(). use vctrs::vec_rbind() vctrs::vec_cbind() hood, names clearly reflect semantics.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/map_dfr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functions that return data frames — map_dfr","text":"","code":"map_dfr(.x, .f, ..., .id = NULL)  map_dfc(.x, .f, ...)  imap_dfr(.x, .f, ..., .id = NULL)  imap_dfc(.x, .f, ...)  map2_dfr(.x, .y, .f, ..., .id = NULL)  map2_dfc(.x, .y, .f, ...)  pmap_dfr(.l, .f, ..., .id = NULL)  pmap_dfc(.l, .f, ...)"},{"path":"https://purrr.tidyverse.org/dev/reference/map_dfr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functions that return data frames — map_dfr","text":".id Either string NULL. string, output contain variable name, storing either name (.x named) index (.x unnamed) input. NULL, default, variable created. applies _dfr variant.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/map_dfr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functions that return data frames — map_dfr","text":"","code":"# map --------------------------------------------- # Was: mtcars |>   split(mtcars$cyl) |>   map(\\(df) lm(mpg ~ wt, data = df)) |>   map_dfr(\\(mod) as.data.frame(t(as.matrix(coef(mod))))) #>   (Intercept)        wt #> 1    39.57120 -5.647025 #> 2    28.40884 -2.780106 #> 3    23.86803 -2.192438  # Now: mtcars |>   split(mtcars$cyl) |>   map(\\(df) lm(mpg ~ wt, data = df)) |>   map(\\(mod) as.data.frame(t(as.matrix(coef(mod))))) |>   list_rbind() #>   (Intercept)        wt #> 1    39.57120 -5.647025 #> 2    28.40884 -2.780106 #> 3    23.86803 -2.192438  # for certain pathological inputs `map_dfr()` and `map_dfc()` actually # both combine the list by column df <- data.frame(   x = c(\" 13\", \"  15 \"),   y = c(\"  34\",  \" 67 \") )  # Was: map_dfr(df, trimws) #> # A tibble: 2 × 2 #>   x     y     #>   <chr> <chr> #> 1 13    34    #> 2 15    67    map_dfc(df, trimws) #> # A tibble: 2 × 2 #>   x     y     #>   <chr> <chr> #> 1 13    34    #> 2 15    67     # But list_rbind()/list_cbind() fail because they require data frame inputs try(map(df, trimws) |> list_rbind()) #> Error in list_rbind(map(df, trimws)) :  #>   Each element of `x` must be either a data frame or `NULL`. #> ℹ Elements 1 and 2 are not.  # Instead, use modify() to apply a function to each column of a data frame modify(df, trimws) #>    x  y #> 1 13 34 #> 2 15 67  # map2 ---------------------------------------------  ex_fun <- function(arg1, arg2){   col <- arg1 + arg2   x <- as.data.frame(col) } arg1 <- 1:4 arg2 <- 10:13  # was map2_dfr(arg1, arg2, ex_fun) #>   col #> 1  11 #> 2  13 #> 3  15 #> 4  17 # now map2(arg1, arg2, ex_fun) |> list_rbind() #>   col #> 1  11 #> 2  13 #> 3  15 #> 4  17  # was map2_dfc(arg1, arg2, ex_fun) #> New names: #> • `col` -> `col...1` #> • `col` -> `col...2` #> • `col` -> `col...3` #> • `col` -> `col...4` #>   col...1 col...2 col...3 col...4 #> 1      11      13      15      17 # now map2(arg1, arg2, ex_fun) |> list_cbind() #> New names: #> • `col` -> `col...1` #> • `col` -> `col...2` #> • `col` -> `col...3` #> • `col` -> `col...4` #>   col...1 col...2 col...3 col...4 #> 1      11      13      15      17"},{"path":"https://purrr.tidyverse.org/dev/reference/map_if.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function to each element of a vector conditionally — map_if","title":"Apply a function to each element of a vector conditionally — map_if","text":"functions map_if() map_at() take .x input, apply function .f elements .x, return list length input. map_if() takes predicate function .p input determine elements .x transformed .f. map_at() takes vector names positions .specify elements .x transformed .f.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/map_if.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function to each element of a vector conditionally — map_if","text":"","code":"map_if(.x, .p, .f, ..., .else = NULL)  map_at(.x, .at, .f, ..., .progress = FALSE)"},{"path":"https://purrr.tidyverse.org/dev/reference/map_if.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function to each element of a vector conditionally — map_if","text":".x list atomic vector. .p single predicate function, formula describing predicate function, logical vector length .x. Alternatively, elements .x lists objects, string indicating name logical element inner lists. elements .p evaluates TRUE modified. .f function, specified one following ways: named function, e.g. mean. anonymous function, e.g. \\(x) x + 1 function(x) x + 1. formula, e.g. ~ .x + 1. must use .x refer first argument. longer recommended. string, integer, list, e.g. \"idx\", 1, list(\"idx\", 1) shorthand \\(x) pluck(x, \"idx\"), \\(x) pluck(x, 1), \\(x) pluck(x, \"idx\", 1) respectively. Optionally supply .default set default value indexed element NULL exist.  Wrap function in_parallel() declare performed parallel. See in_parallel() details. Use ... permitted context. ... Additional arguments passed mapped function. now generally recommend using ... pass additional (constant) arguments .f. Instead use shorthand anonymous function:   makes easier understand arguments belong function tend yield better error messages. .else function applied elements .x .p returns FALSE. .logical, integer, character vector giving elements select. Alternatively, function takes vector names, returns logical, integer, character vector elements select. : tidyselect package installed, can use vars() tidyselect helpers select elements. .progress Whether show progress bar. Use TRUE turn basic progress bar, use string give name, see progress_bars details.","code":"# Instead of x |> map(f, 1, 2, collapse = \",\") # do: x |> map(\\(x) f(x, 1, 2, collapse = \",\"))"},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/map_if.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function to each element of a vector conditionally — map_if","text":"","code":"# Use a predicate function to decide whether to map a function: iris |> map_if(is.factor, as.character) |> str() #> List of 5 #>  $ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #>  $ Sepal.Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #>  $ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #>  $ Petal.Width : num [1:150] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #>  $ Species     : chr [1:150] \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...  # Specify an alternative with the `.else` argument: iris |> map_if(is.factor, as.character, .else = as.integer) |> str() #> List of 5 #>  $ Sepal.Length: int [1:150] 5 4 4 4 5 5 4 5 4 4 ... #>  $ Sepal.Width : int [1:150] 3 3 3 3 3 3 3 3 2 3 ... #>  $ Petal.Length: int [1:150] 1 1 1 1 1 1 1 1 1 1 ... #>  $ Petal.Width : int [1:150] 0 0 0 0 0 0 0 0 0 0 ... #>  $ Species     : chr [1:150] \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...  # Use numeric vector of positions select elements to change: iris |> map_at(c(4, 5), is.numeric) |> str() #> List of 5 #>  $ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #>  $ Sepal.Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #>  $ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #>  $ Petal.Width : logi TRUE #>  $ Species     : logi FALSE  # Use vector of names to specify which elements to change: iris |> map_at(\"Species\", toupper) |> str() #> List of 5 #>  $ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #>  $ Sepal.Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #>  $ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #>  $ Petal.Width : num [1:150] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #>  $ Species     : chr [1:150] \"SETOSA\" \"SETOSA\" \"SETOSA\" \"SETOSA\" ..."},{"path":"https://purrr.tidyverse.org/dev/reference/map_raw.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions that return raw vectors — map_raw","title":"Functions that return raw vectors — map_raw","text":"functions deprecated purrr 1.0.0 limited use can now use map_vec() instead. variants map(), map2(), imap(), pmap(), flatten() return raw vectors.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/map_raw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functions that return raw vectors — map_raw","text":"","code":"map_raw(.x, .f, ...)  map2_raw(.x, .y, .f, ...)  imap_raw(.x, .f, ...)  pmap_raw(.l, .f, ...)  flatten_raw(.x)"},{"path":"https://purrr.tidyverse.org/dev/reference/modify.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify elements selectively — modify","title":"Modify elements selectively — modify","text":"Unlike map() variants always return fixed object type (list map(), integer vector map_int(), etc), modify() family always returns type input object. modify() shortcut x[[]] <- f(x[[]]); return(x). modify_if() modifies elements x satisfy predicate leaves others unchanged. modify_at() modifies elements given names positions. modify2() modifies elements .x also passes elements .y .f, just like map2(). imodify() passes names indices .f like imap() . modify_in() modifies single element pluck() location.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/modify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify elements selectively — modify","text":"","code":"modify(.x, .f, ...)  modify_if(.x, .p, .f, ..., .else = NULL)  modify_at(.x, .at, .f, ...)  modify2(.x, .y, .f, ...)  imodify(.x, .f, ...)"},{"path":"https://purrr.tidyverse.org/dev/reference/modify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify elements selectively — modify","text":".x vector. .f function specified way corresponding map function. ... Additional arguments passed mapped function. now generally recommend using ... pass additional (constant) arguments .f. Instead use shorthand anonymous function:   makes easier understand arguments belong function tend yield better error messages. .p single predicate function, formula describing predicate function, logical vector length .x. Alternatively, elements .x lists objects, string indicating name logical element inner lists. elements .p evaluates TRUE modified. .else function applied elements .x .p returns FALSE. .logical, integer, character vector giving elements select. Alternatively, function takes vector names, returns logical, integer, character vector elements select. : tidyselect package installed, can use vars() tidyselect helpers select elements. .y vector, usually length .x.","code":"# Instead of x |> map(f, 1, 2, collapse = \",\") # do: x |> map(\\(x) f(x, 1, 2, collapse = \",\"))"},{"path":"https://purrr.tidyverse.org/dev/reference/modify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modify elements selectively — modify","text":"object class .x","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/modify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Modify elements selectively — modify","text":"Since transformation can alter structure input; responsibility ensure transformation produces valid output. example, modifying data frame, .f must preserve length input.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/modify.html","id":"genericity","dir":"Reference","previous_headings":"","what":"Genericity","title":"Modify elements selectively — modify","text":"modify() variants generic classes implement length(), [[ [[<- methods. default implementation compatible class, can override methods. implement modify() method, make sure satisfies following invariants:   invariants known functor laws computer science.","code":"modify(x, identity) === x modify(x, compose(f, g)) === modify(x, g) |> modify(f)"},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/modify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modify elements selectively — modify","text":"","code":"# Convert factors to characters iris |>   modify_if(is.factor, as.character) |>   str() #> 'data.frame':\t150 obs. of  5 variables: #>  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #>  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #>  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #>  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #>  $ Species     : chr  \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...  # Specify which columns to map with a numeric vector of positions: mtcars |> modify_at(c(1, 4, 5), as.character) |> str() #> 'data.frame':\t32 obs. of  11 variables: #>  $ mpg : chr  \"21\" \"21\" \"22.8\" \"21.4\" ... #>  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ... #>  $ disp: num  160 160 108 258 360 ... #>  $ hp  : chr  \"110\" \"110\" \"93\" \"110\" ... #>  $ drat: chr  \"3.9\" \"3.9\" \"3.85\" \"3.08\" ... #>  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ... #>  $ qsec: num  16.5 17 18.6 19.4 17 ... #>  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ... #>  $ am  : num  1 1 1 0 0 0 0 0 0 0 ... #>  $ gear: num  4 4 4 3 3 3 3 4 4 4 ... #>  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...  # Or with a vector of names: mtcars |> modify_at(c(\"cyl\", \"am\"), as.character) |> str() #> 'data.frame':\t32 obs. of  11 variables: #>  $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... #>  $ cyl : chr  \"6\" \"6\" \"4\" \"6\" ... #>  $ disp: num  160 160 108 258 360 ... #>  $ hp  : num  110 110 93 110 175 105 245 62 95 123 ... #>  $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... #>  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ... #>  $ qsec: num  16.5 17 18.6 19.4 17 ... #>  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ... #>  $ am  : chr  \"1\" \"1\" \"1\" \"0\" ... #>  $ gear: num  4 4 4 3 3 3 3 4 4 4 ... #>  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...  list(x = sample(c(TRUE, FALSE), 100, replace = TRUE), y = 1:100) |>   list_transpose(simplify = FALSE) |>   modify_if(\"x\", \\(l) list(x = l$x, y = l$y * 100)) |>   list_transpose() #> $x #>   [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE #>  [12]  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE #>  [23] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE #>  [34] FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE #>  [45]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE #>  [56]  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE #>  [67] FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE #>  [78]  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE #>  [89]  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE #> [100] FALSE #>  #> $y #>   [1]  100  200  300    4  500    6  700    8  900 1000   11 1200 1300 #>  [14]   14   15 1600   17 1800   19 2000   21   22   23 2400   25   26 #>  [27]   27   28   29 3000   31   32   33   34 3500   36   37 3800   39 #>  [40] 4000   41 4200 4300   44 4500 4600   47   48   49   50   51 5200 #>  [53] 5300   54   55 5600   57   58 5900 6000 6100 6200 6300   64   65 #>  [66]   66   67 6800   69 7000   71 7200 7300 7400   75   76 7700 7800 #>  [79]   79   80 8100 8200   83   84 8500   86 8700 8800 8900 9000 9100 #>  [92]   92   93 9400 9500 9600   97 9800 9900  100 #>   # Use modify2() to map over two vectors and preserve the type of # the first one: x <- c(foo = 1L, bar = 2L) y <- c(TRUE, FALSE) modify2(x, y, \\(x, cond) if (cond) x else 0L) #> foo bar  #>   1   0   # Use a predicate function to decide whether to map a function: modify_if(iris, is.factor, as.character) #>     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species #> 1            5.1         3.5          1.4         0.2     setosa #> 2            4.9         3.0          1.4         0.2     setosa #> 3            4.7         3.2          1.3         0.2     setosa #> 4            4.6         3.1          1.5         0.2     setosa #> 5            5.0         3.6          1.4         0.2     setosa #> 6            5.4         3.9          1.7         0.4     setosa #> 7            4.6         3.4          1.4         0.3     setosa #> 8            5.0         3.4          1.5         0.2     setosa #> 9            4.4         2.9          1.4         0.2     setosa #> 10           4.9         3.1          1.5         0.1     setosa #> 11           5.4         3.7          1.5         0.2     setosa #> 12           4.8         3.4          1.6         0.2     setosa #> 13           4.8         3.0          1.4         0.1     setosa #> 14           4.3         3.0          1.1         0.1     setosa #> 15           5.8         4.0          1.2         0.2     setosa #> 16           5.7         4.4          1.5         0.4     setosa #> 17           5.4         3.9          1.3         0.4     setosa #> 18           5.1         3.5          1.4         0.3     setosa #> 19           5.7         3.8          1.7         0.3     setosa #> 20           5.1         3.8          1.5         0.3     setosa #> 21           5.4         3.4          1.7         0.2     setosa #> 22           5.1         3.7          1.5         0.4     setosa #> 23           4.6         3.6          1.0         0.2     setosa #> 24           5.1         3.3          1.7         0.5     setosa #> 25           4.8         3.4          1.9         0.2     setosa #> 26           5.0         3.0          1.6         0.2     setosa #> 27           5.0         3.4          1.6         0.4     setosa #> 28           5.2         3.5          1.5         0.2     setosa #> 29           5.2         3.4          1.4         0.2     setosa #> 30           4.7         3.2          1.6         0.2     setosa #> 31           4.8         3.1          1.6         0.2     setosa #> 32           5.4         3.4          1.5         0.4     setosa #> 33           5.2         4.1          1.5         0.1     setosa #> 34           5.5         4.2          1.4         0.2     setosa #> 35           4.9         3.1          1.5         0.2     setosa #> 36           5.0         3.2          1.2         0.2     setosa #> 37           5.5         3.5          1.3         0.2     setosa #> 38           4.9         3.6          1.4         0.1     setosa #> 39           4.4         3.0          1.3         0.2     setosa #> 40           5.1         3.4          1.5         0.2     setosa #> 41           5.0         3.5          1.3         0.3     setosa #> 42           4.5         2.3          1.3         0.3     setosa #> 43           4.4         3.2          1.3         0.2     setosa #> 44           5.0         3.5          1.6         0.6     setosa #> 45           5.1         3.8          1.9         0.4     setosa #> 46           4.8         3.0          1.4         0.3     setosa #> 47           5.1         3.8          1.6         0.2     setosa #> 48           4.6         3.2          1.4         0.2     setosa #> 49           5.3         3.7          1.5         0.2     setosa #> 50           5.0         3.3          1.4         0.2     setosa #> 51           7.0         3.2          4.7         1.4 versicolor #> 52           6.4         3.2          4.5         1.5 versicolor #> 53           6.9         3.1          4.9         1.5 versicolor #> 54           5.5         2.3          4.0         1.3 versicolor #> 55           6.5         2.8          4.6         1.5 versicolor #> 56           5.7         2.8          4.5         1.3 versicolor #> 57           6.3         3.3          4.7         1.6 versicolor #> 58           4.9         2.4          3.3         1.0 versicolor #> 59           6.6         2.9          4.6         1.3 versicolor #> 60           5.2         2.7          3.9         1.4 versicolor #> 61           5.0         2.0          3.5         1.0 versicolor #> 62           5.9         3.0          4.2         1.5 versicolor #> 63           6.0         2.2          4.0         1.0 versicolor #> 64           6.1         2.9          4.7         1.4 versicolor #> 65           5.6         2.9          3.6         1.3 versicolor #> 66           6.7         3.1          4.4         1.4 versicolor #> 67           5.6         3.0          4.5         1.5 versicolor #> 68           5.8         2.7          4.1         1.0 versicolor #> 69           6.2         2.2          4.5         1.5 versicolor #> 70           5.6         2.5          3.9         1.1 versicolor #> 71           5.9         3.2          4.8         1.8 versicolor #> 72           6.1         2.8          4.0         1.3 versicolor #> 73           6.3         2.5          4.9         1.5 versicolor #> 74           6.1         2.8          4.7         1.2 versicolor #> 75           6.4         2.9          4.3         1.3 versicolor #> 76           6.6         3.0          4.4         1.4 versicolor #> 77           6.8         2.8          4.8         1.4 versicolor #> 78           6.7         3.0          5.0         1.7 versicolor #> 79           6.0         2.9          4.5         1.5 versicolor #> 80           5.7         2.6          3.5         1.0 versicolor #> 81           5.5         2.4          3.8         1.1 versicolor #> 82           5.5         2.4          3.7         1.0 versicolor #> 83           5.8         2.7          3.9         1.2 versicolor #> 84           6.0         2.7          5.1         1.6 versicolor #> 85           5.4         3.0          4.5         1.5 versicolor #> 86           6.0         3.4          4.5         1.6 versicolor #> 87           6.7         3.1          4.7         1.5 versicolor #> 88           6.3         2.3          4.4         1.3 versicolor #> 89           5.6         3.0          4.1         1.3 versicolor #> 90           5.5         2.5          4.0         1.3 versicolor #> 91           5.5         2.6          4.4         1.2 versicolor #> 92           6.1         3.0          4.6         1.4 versicolor #> 93           5.8         2.6          4.0         1.2 versicolor #> 94           5.0         2.3          3.3         1.0 versicolor #> 95           5.6         2.7          4.2         1.3 versicolor #> 96           5.7         3.0          4.2         1.2 versicolor #> 97           5.7         2.9          4.2         1.3 versicolor #> 98           6.2         2.9          4.3         1.3 versicolor #> 99           5.1         2.5          3.0         1.1 versicolor #> 100          5.7         2.8          4.1         1.3 versicolor #> 101          6.3         3.3          6.0         2.5  virginica #> 102          5.8         2.7          5.1         1.9  virginica #> 103          7.1         3.0          5.9         2.1  virginica #> 104          6.3         2.9          5.6         1.8  virginica #> 105          6.5         3.0          5.8         2.2  virginica #> 106          7.6         3.0          6.6         2.1  virginica #> 107          4.9         2.5          4.5         1.7  virginica #> 108          7.3         2.9          6.3         1.8  virginica #> 109          6.7         2.5          5.8         1.8  virginica #> 110          7.2         3.6          6.1         2.5  virginica #> 111          6.5         3.2          5.1         2.0  virginica #> 112          6.4         2.7          5.3         1.9  virginica #> 113          6.8         3.0          5.5         2.1  virginica #> 114          5.7         2.5          5.0         2.0  virginica #> 115          5.8         2.8          5.1         2.4  virginica #> 116          6.4         3.2          5.3         2.3  virginica #> 117          6.5         3.0          5.5         1.8  virginica #> 118          7.7         3.8          6.7         2.2  virginica #> 119          7.7         2.6          6.9         2.3  virginica #> 120          6.0         2.2          5.0         1.5  virginica #> 121          6.9         3.2          5.7         2.3  virginica #> 122          5.6         2.8          4.9         2.0  virginica #> 123          7.7         2.8          6.7         2.0  virginica #> 124          6.3         2.7          4.9         1.8  virginica #> 125          6.7         3.3          5.7         2.1  virginica #> 126          7.2         3.2          6.0         1.8  virginica #> 127          6.2         2.8          4.8         1.8  virginica #> 128          6.1         3.0          4.9         1.8  virginica #> 129          6.4         2.8          5.6         2.1  virginica #> 130          7.2         3.0          5.8         1.6  virginica #> 131          7.4         2.8          6.1         1.9  virginica #> 132          7.9         3.8          6.4         2.0  virginica #> 133          6.4         2.8          5.6         2.2  virginica #> 134          6.3         2.8          5.1         1.5  virginica #> 135          6.1         2.6          5.6         1.4  virginica #> 136          7.7         3.0          6.1         2.3  virginica #> 137          6.3         3.4          5.6         2.4  virginica #> 138          6.4         3.1          5.5         1.8  virginica #> 139          6.0         3.0          4.8         1.8  virginica #> 140          6.9         3.1          5.4         2.1  virginica #> 141          6.7         3.1          5.6         2.4  virginica #> 142          6.9         3.1          5.1         2.3  virginica #> 143          5.8         2.7          5.1         1.9  virginica #> 144          6.8         3.2          5.9         2.3  virginica #> 145          6.7         3.3          5.7         2.5  virginica #> 146          6.7         3.0          5.2         2.3  virginica #> 147          6.3         2.5          5.0         1.9  virginica #> 148          6.5         3.0          5.2         2.0  virginica #> 149          6.2         3.4          5.4         2.3  virginica #> 150          5.9         3.0          5.1         1.8  virginica  # Specify an alternative with the `.else` argument: modify_if(iris, is.factor, as.character, .else = as.integer) #>     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species #> 1              5           3            1           0     setosa #> 2              4           3            1           0     setosa #> 3              4           3            1           0     setosa #> 4              4           3            1           0     setosa #> 5              5           3            1           0     setosa #> 6              5           3            1           0     setosa #> 7              4           3            1           0     setosa #> 8              5           3            1           0     setosa #> 9              4           2            1           0     setosa #> 10             4           3            1           0     setosa #> 11             5           3            1           0     setosa #> 12             4           3            1           0     setosa #> 13             4           3            1           0     setosa #> 14             4           3            1           0     setosa #> 15             5           4            1           0     setosa #> 16             5           4            1           0     setosa #> 17             5           3            1           0     setosa #> 18             5           3            1           0     setosa #> 19             5           3            1           0     setosa #> 20             5           3            1           0     setosa #> 21             5           3            1           0     setosa #> 22             5           3            1           0     setosa #> 23             4           3            1           0     setosa #> 24             5           3            1           0     setosa #> 25             4           3            1           0     setosa #> 26             5           3            1           0     setosa #> 27             5           3            1           0     setosa #> 28             5           3            1           0     setosa #> 29             5           3            1           0     setosa #> 30             4           3            1           0     setosa #> 31             4           3            1           0     setosa #> 32             5           3            1           0     setosa #> 33             5           4            1           0     setosa #> 34             5           4            1           0     setosa #> 35             4           3            1           0     setosa #> 36             5           3            1           0     setosa #> 37             5           3            1           0     setosa #> 38             4           3            1           0     setosa #> 39             4           3            1           0     setosa #> 40             5           3            1           0     setosa #> 41             5           3            1           0     setosa #> 42             4           2            1           0     setosa #> 43             4           3            1           0     setosa #> 44             5           3            1           0     setosa #> 45             5           3            1           0     setosa #> 46             4           3            1           0     setosa #> 47             5           3            1           0     setosa #> 48             4           3            1           0     setosa #> 49             5           3            1           0     setosa #> 50             5           3            1           0     setosa #> 51             7           3            4           1 versicolor #> 52             6           3            4           1 versicolor #> 53             6           3            4           1 versicolor #> 54             5           2            4           1 versicolor #> 55             6           2            4           1 versicolor #> 56             5           2            4           1 versicolor #> 57             6           3            4           1 versicolor #> 58             4           2            3           1 versicolor #> 59             6           2            4           1 versicolor #> 60             5           2            3           1 versicolor #> 61             5           2            3           1 versicolor #> 62             5           3            4           1 versicolor #> 63             6           2            4           1 versicolor #> 64             6           2            4           1 versicolor #> 65             5           2            3           1 versicolor #> 66             6           3            4           1 versicolor #> 67             5           3            4           1 versicolor #> 68             5           2            4           1 versicolor #> 69             6           2            4           1 versicolor #> 70             5           2            3           1 versicolor #> 71             5           3            4           1 versicolor #> 72             6           2            4           1 versicolor #> 73             6           2            4           1 versicolor #> 74             6           2            4           1 versicolor #> 75             6           2            4           1 versicolor #> 76             6           3            4           1 versicolor #> 77             6           2            4           1 versicolor #> 78             6           3            5           1 versicolor #> 79             6           2            4           1 versicolor #> 80             5           2            3           1 versicolor #> 81             5           2            3           1 versicolor #> 82             5           2            3           1 versicolor #> 83             5           2            3           1 versicolor #> 84             6           2            5           1 versicolor #> 85             5           3            4           1 versicolor #> 86             6           3            4           1 versicolor #> 87             6           3            4           1 versicolor #> 88             6           2            4           1 versicolor #> 89             5           3            4           1 versicolor #> 90             5           2            4           1 versicolor #> 91             5           2            4           1 versicolor #> 92             6           3            4           1 versicolor #> 93             5           2            4           1 versicolor #> 94             5           2            3           1 versicolor #> 95             5           2            4           1 versicolor #> 96             5           3            4           1 versicolor #> 97             5           2            4           1 versicolor #> 98             6           2            4           1 versicolor #> 99             5           2            3           1 versicolor #> 100            5           2            4           1 versicolor #> 101            6           3            6           2  virginica #> 102            5           2            5           1  virginica #> 103            7           3            5           2  virginica #> 104            6           2            5           1  virginica #> 105            6           3            5           2  virginica #> 106            7           3            6           2  virginica #> 107            4           2            4           1  virginica #> 108            7           2            6           1  virginica #> 109            6           2            5           1  virginica #> 110            7           3            6           2  virginica #> 111            6           3            5           2  virginica #> 112            6           2            5           1  virginica #> 113            6           3            5           2  virginica #> 114            5           2            5           2  virginica #> 115            5           2            5           2  virginica #> 116            6           3            5           2  virginica #> 117            6           3            5           1  virginica #> 118            7           3            6           2  virginica #> 119            7           2            6           2  virginica #> 120            6           2            5           1  virginica #> 121            6           3            5           2  virginica #> 122            5           2            4           2  virginica #> 123            7           2            6           2  virginica #> 124            6           2            4           1  virginica #> 125            6           3            5           2  virginica #> 126            7           3            6           1  virginica #> 127            6           2            4           1  virginica #> 128            6           3            4           1  virginica #> 129            6           2            5           2  virginica #> 130            7           3            5           1  virginica #> 131            7           2            6           1  virginica #> 132            7           3            6           2  virginica #> 133            6           2            5           2  virginica #> 134            6           2            5           1  virginica #> 135            6           2            5           1  virginica #> 136            7           3            6           2  virginica #> 137            6           3            5           2  virginica #> 138            6           3            5           1  virginica #> 139            6           3            4           1  virginica #> 140            6           3            5           2  virginica #> 141            6           3            5           2  virginica #> 142            6           3            5           2  virginica #> 143            5           2            5           1  virginica #> 144            6           3            5           2  virginica #> 145            6           3            5           2  virginica #> 146            6           3            5           2  virginica #> 147            6           2            5           1  virginica #> 148            6           3            5           2  virginica #> 149            6           3            5           2  virginica #> 150            5           3            5           1  virginica"},{"path":"https://purrr.tidyverse.org/dev/reference/modify_in.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify a pluck location — modify_in","title":"Modify a pluck location — modify_in","text":"assign_in() takes data structure pluck location, assigns value , returns modified data structure. modify_in() applies function pluck location, assigns result back location assign_in(), returns modified data structure.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/modify_in.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify a pluck location — modify_in","text":"","code":"modify_in(.x, .where, .f, ...)  assign_in(x, where, value)"},{"path":"https://purrr.tidyverse.org/dev/reference/modify_in.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify a pluck location — modify_in","text":".x, x vector environment ., pluck location, numeric vector positions, character vector names, list combining . location must exist data structure. .f function apply pluck location given .. ... Arguments passed .f. value value replace .x pluck location. Use zap() instead remove element.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/modify_in.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modify a pluck location — modify_in","text":"","code":"# Recall that pluck() returns a component of a data structure that # might be arbitrarily deep x <- list(list(bar = 1, foo = 2)) pluck(x, 1, \"foo\") #> [1] 2  # Use assign_in() to modify the pluck location: str(assign_in(x, list(1, \"foo\"), 100)) #> List of 1 #>  $ :List of 2 #>   ..$ bar: num 1 #>   ..$ foo: num 100 # Or zap to remove it str(assign_in(x, list(1, \"foo\"), zap())) #> List of 1 #>  $ :List of 1 #>   ..$ bar: num 1  # Like pluck(), this works even when the element (or its parents) don't exist pluck(x, 1, \"baz\") #> NULL str(assign_in(x, list(2, \"baz\"), 100)) #> List of 2 #>  $ :List of 2 #>   ..$ bar: num 1 #>   ..$ foo: num 2 #>  $ :List of 1 #>   ..$ baz: num 100  # modify_in() applies a function to that location and update the # element in place: modify_in(x, list(1, \"foo\"), \\(x) x * 200) #> [[1]] #> [[1]]$bar #> [1] 1 #>  #> [[1]]$foo #> [1] 400 #>  #>   # Additional arguments are passed to the function in the ordinary way: modify_in(x, list(1, \"foo\"), `+`, 100) #> [[1]] #> [[1]]$bar #> [1] 1 #>  #> [[1]]$foo #> [1] 102 #>  #>"},{"path":"https://purrr.tidyverse.org/dev/reference/modify_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Recursively modify a list — modify_tree","title":"Recursively modify a list — modify_tree","text":"modify_tree() allows recursively modify list, supplying functions either modify leaf node ().","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/modify_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recursively modify a list — modify_tree","text":"","code":"modify_tree(   x,   ...,   leaf = identity,   is_node = NULL,   pre = identity,   post = identity )"},{"path":"https://purrr.tidyverse.org/dev/reference/modify_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recursively modify a list — modify_tree","text":"x list. ... Reserved future use. Must empty leaf function applied leaf. is_node predicate function determines whether element node (returning TRUE) leaf (returning FALSE). default value, NULL, treats simple lists nodes everything else (including richer objects like data frames linear models) leaves, using vctrs::obj_is_list(). recurse objects built lists use .list(). pre, post Functions applied node. pre applied way \"\", .e. leaves transformed leaf, post applied way \"\", .e. leaves transformed.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/modify_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recursively modify a list — modify_tree","text":"","code":"x <- list(list(a = 2:1, c = list(b1 = 2), b = list(c2 = 3, c1 = 4))) x |> str() #> List of 1 #>  $ :List of 3 #>   ..$ a: int [1:2] 2 1 #>   ..$ c:List of 1 #>   .. ..$ b1: num 2 #>   ..$ b:List of 2 #>   .. ..$ c2: num 3 #>   .. ..$ c1: num 4  # Transform each leaf x |> modify_tree(leaf = \\(x) x + 100) |>  str() #> List of 1 #>  $ :List of 3 #>   ..$ a: num [1:2] 102 101 #>   ..$ c:List of 1 #>   .. ..$ b1: num 102 #>   ..$ b:List of 2 #>   .. ..$ c2: num 103 #>   .. ..$ c1: num 104  # Recursively sort the nodes sort_named <- function(x) {   nms <- names(x)   if (!is.null(nms)) {     x[order(nms)]   } else {     x    } } x |> modify_tree(post = sort_named) |> str() #> List of 1 #>  $ :List of 3 #>   ..$ a: int [1:2] 2 1 #>   ..$ b:List of 2 #>   .. ..$ c1: num 4 #>   .. ..$ c2: num 3 #>   ..$ c:List of 1 #>   .. ..$ b1: num 2"},{"path":"https://purrr.tidyverse.org/dev/reference/negate.html","id":null,"dir":"Reference","previous_headings":"","what":"Negate a predicate function so it selects what it previously rejected — negate","title":"Negate a predicate function so it selects what it previously rejected — negate","text":"Negating function changes TRUE FALSE FALSE TRUE.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/negate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negate a predicate function so it selects what it previously rejected — negate","text":"","code":"negate(.p)"},{"path":"https://purrr.tidyverse.org/dev/reference/negate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negate a predicate function so it selects what it previously rejected — negate","text":".p predicate function (.e. function returns either TRUE FALSE) specified one following ways: named function, e.g. .character. anonymous function, e.g. \\(x) (x < 0) function(x) (x < 0). formula, e.g. ~ (.x < 0). must use .x refer first argument). longer recommended.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/negate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negate a predicate function so it selects what it previously rejected — negate","text":"new predicate function.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/negate.html","id":"adverbs","dir":"Reference","previous_headings":"","what":"Adverbs","title":"Negate a predicate function so it selects what it previously rejected — negate","text":"function called adverb modifies effect function (verb). like include function created adverb package, sure read faq-adverbs-export.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/negate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Negate a predicate function so it selects what it previously rejected — negate","text":"","code":"x <- list(x = 1:10, y = rbernoulli(10), z = letters) x |> keep(is.numeric) |> names() #> [1] \"x\" x |> keep(negate(is.numeric)) |> names() #> [1] \"y\" \"z\" # Same as x |> discard(is.numeric) #> $y #>  [1]  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE #>  #> $z #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" #> [17] \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>"},{"path":"https://purrr.tidyverse.org/dev/reference/partial.html","id":null,"dir":"Reference","previous_headings":"","what":"Partially apply a function, filling in some arguments — partial","title":"Partially apply a function, filling in some arguments — partial","text":"Partial function application allows modify function pre-filling arguments. particularly useful conjunction functionals function operators.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/partial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partially apply a function, filling in some arguments — partial","text":"","code":"partial(.f, ...)"},{"path":"https://purrr.tidyverse.org/dev/reference/partial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partially apply a function, filling in some arguments — partial","text":".f function. output source read well, named function. ... named arguments .f partially applied. Pass empty ... =  argument specify position future arguments relative partialised ones. See rlang::call_modify() learn syntax. dots support quasiquotation. unquote value, evaluated function creation time.  Otherwise, evaluated time function called.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/partial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Partially apply a function, filling in some arguments — partial","text":"function takes arguments .f, returns different value, described .","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/partial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Partially apply a function, filling in some arguments — partial","text":"partial() creates function takes ... arguments. Unlike compose() function operators like negate(), reuse function signature .f. partial() explicitly supports NSE functions use substitute() arguments. way support forward arguments dots. unsupported patterns: possible call partial() repeatedly argument pre-fill different expression. possible refer arguments pre-filled argument.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/partial.html","id":"adverbs","dir":"Reference","previous_headings":"","what":"Adverbs","title":"Partially apply a function, filling in some arguments — partial","text":"function called adverb modifies effect function (verb). like include function created adverb package, sure read faq-adverbs-export.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/partial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partially apply a function, filling in some arguments — partial","text":"","code":"# Partial is designed to replace the use of anonymous functions for # filling in function arguments. Instead of: compact1 <- function(x) discard(x, is.null)  # we can write: compact2 <- partial(discard, .p = is.null)  # partial() works fine with functions that do non-standard # evaluation my_long_variable <- 1:10 plot2 <- partial(plot, my_long_variable) plot2()  plot2(runif(10), type = \"l\")   # Note that you currently can't partialise arguments multiple times: my_mean <- partial(mean, na.rm = TRUE) my_mean <- partial(my_mean, na.rm = FALSE) try(my_mean(1:10)) #> Error in mean.default(na.rm = TRUE, ...) :  #>   formal argument \"na.rm\" matched by multiple actual arguments   # The evaluation of arguments normally occurs \"lazily\". Concretely, # this means that arguments are repeatedly evaluated across invocations: f <- partial(runif, n = rpois(1, 5)) f #> <partialised> #> function (...)  #> runif(n = rpois(1, 5), ...) #> <environment: 0x55827a00b708> f() #> [1] 0.9465589 0.8754108 0.2600589 0.6572984 f() #> [1] 0.318848 0.623061  # You can unquote an argument to fix it to a particular value. # Unquoted arguments are evaluated only once when the function is created: f <- partial(runif, n = !!rpois(1, 5)) f #> <partialised> #> function (...)  #> runif(n = 5L, ...) #> <environment: 0x55827a00b708> f() #> [1] 0.7082934 0.8900290 0.1043065 0.6304117 0.8415589 f() #> [1] 0.3642624 0.6229228 0.4607475 0.1634123 0.5138669   # By default, partialised arguments are passed before new ones: my_list <- partial(list, 1, 2) my_list(\"foo\") #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] \"foo\" #>   # Control the position of these arguments by passing an empty # `... = ` argument: my_list <- partial(list, 1, ... = , 2) my_list(\"foo\") #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] \"foo\" #>  #> [[3]] #> [1] 2 #>"},{"path":"https://purrr.tidyverse.org/dev/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"Pipe operator","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://purrr.tidyverse.org/dev/reference/pluck.html","id":null,"dir":"Reference","previous_headings":"","what":"Safely get or set an element deep within a nested data structure — pluck","title":"Safely get or set an element deep within a nested data structure — pluck","text":"pluck() implements generalised form [[ allow index deeply flexibly data structures. always succeeds, returning .default index trying access exist NULL. pluck<-() assignment equivalent, allowing modify object deep within nested data structure. pluck_exists() tells whether object exists using rules pluck (.e. NULL element equivalent absent element).","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/pluck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safely get or set an element deep within a nested data structure — pluck","text":"","code":"pluck(.x, ..., .default = NULL)  pluck(.x, ...) <- value  pluck_exists(.x, ...)"},{"path":"https://purrr.tidyverse.org/dev/reference/pluck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safely get or set an element deep within a nested data structure — pluck","text":".x, x vector environment ... list accessors indexing object. Can positive integer, negative integer (index right), string (index names), accessor function (except assignment variants support names positions). object indexed S4 object, accessing name return corresponding slot. Dynamic dots supported. particular, accessors stored list, can splice !!!. .default Value use target NULL absent. value value replace .x pluck location. Use zap() instead remove element.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/pluck.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Safely get or set an element deep within a nested data structure — pluck","text":"can pluck chuck standard accessors like integer positions string names, also accepts arbitrary accessor functions, .e. functions take object return internal piece. often readable mix operators accessors reads linearly free syntactic cruft. Compare: accessor(x[[1]])$foo pluck(x, 1, accessor, \"foo\"). accessors never partial-match. unlike $ select disp object write mtcars$di.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/pluck.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Safely get or set an element deep within a nested data structure — pluck","text":"","code":"# Let's create a list of data structures: obj1 <- list(\"a\", list(1, elt = \"foo\")) obj2 <- list(\"b\", list(2, elt = \"bar\")) x <- list(obj1, obj2)  # pluck() provides a way of retrieving objects from such data # structures using a combination of numeric positions, vector or # list names, and accessor functions.  # Numeric positions index into the list by position, just like `[[`: pluck(x, 1) #> [[1]] #> [1] \"a\" #>  #> [[2]] #> [[2]][[1]] #> [1] 1 #>  #> [[2]]$elt #> [1] \"foo\" #>  #>  # same as x[[1]]  # Index from the back pluck(x, -1) #> [[1]] #> [1] \"b\" #>  #> [[2]] #> [[2]][[1]] #> [1] 2 #>  #> [[2]]$elt #> [1] \"bar\" #>  #>  # same as x[[2]]  pluck(x, 1, 2) #> [[1]] #> [1] 1 #>  #> $elt #> [1] \"foo\" #>  # same as x[[1]][[2]]  # Supply names to index into named vectors: pluck(x, 1, 2, \"elt\") #> [1] \"foo\" # same as x[[1]][[2]][[\"elt\"]]  # By default, pluck() consistently returns `NULL` when an element # does not exist: pluck(x, 10) #> NULL try(x[[10]]) #> Error in x[[10]] : subscript out of bounds  # You can also supply a default value for non-existing elements: pluck(x, 10, .default = NA) #> [1] NA  # The map() functions use pluck() by default to retrieve multiple # values from a list: map_chr(x, 1) #> [1] \"a\" \"b\" map_int(x, c(2, 1)) #> [1] 1 2  # pluck() also supports accessor functions: my_element <- function(x) x[[2]]$elt pluck(x, 1, my_element) #> [1] \"foo\" pluck(x, 2, my_element) #> [1] \"bar\"  # Even for this simple data structure, this is more readable than # the alternative form because it requires you to read both from # right-to-left and from left-to-right in different parts of the # expression: my_element(x[[1]]) #> [1] \"foo\"  # If you have a list of accessors, you can splice those in with `!!!`: idx <- list(1, my_element) pluck(x, !!!idx) #> [1] \"foo\""},{"path":"https://purrr.tidyverse.org/dev/reference/pluck_depth.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the depth of a vector — pluck_depth","title":"Compute the depth of a vector — pluck_depth","text":"depth vector many levels can index/pluck . pluck_depth() previously called vec_depth().","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/pluck_depth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the depth of a vector — pluck_depth","text":"","code":"pluck_depth(x, is_node = NULL)"},{"path":"https://purrr.tidyverse.org/dev/reference/pluck_depth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the depth of a vector — pluck_depth","text":"x vector is_node Optionally override default criteria determine element can recursed within. default matches behaviour pluck() can recurse lists expressions.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/pluck_depth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the depth of a vector — pluck_depth","text":"integer.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/pluck_depth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the depth of a vector — pluck_depth","text":"","code":"x <- list(   list(),   list(list()),   list(list(list(1))) ) pluck_depth(x) #> [1] 5 x |> map_int(pluck_depth) #> [1] 1 2 4"},{"path":"https://purrr.tidyverse.org/dev/reference/pmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Map over multiple input simultaneously (in ","title":"Map over multiple input simultaneously (in ","text":"functions variants map() iterate multiple arguments simultaneously. parallel sense input processed parallel others, sense multicore computing, .e. share notion \"parallel\" base::pmax() base::pmin().","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/pmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map over multiple input simultaneously (in ","text":"","code":"pmap(.l, .f, ..., .progress = FALSE)  pmap_lgl(.l, .f, ..., .progress = FALSE)  pmap_int(.l, .f, ..., .progress = FALSE)  pmap_dbl(.l, .f, ..., .progress = FALSE)  pmap_chr(.l, .f, ..., .progress = FALSE)  pmap_vec(.l, .f, ..., .ptype = NULL, .progress = FALSE)  pwalk(.l, .f, ..., .progress = FALSE)"},{"path":"https://purrr.tidyverse.org/dev/reference/pmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map over multiple input simultaneously (in ","text":".l list vectors. length .l determines number arguments .f called . Arguments supply position unnamed, name named. Vectors length 1 recycled length; elements must length. data frame important special case .l. cause .f called row. .f function, specified one following ways: named function. anonymous function, e.g. \\(x, y, z) x + y / z function(x, y, z) x + y / z formula, e.g. ~ ..1 + ..2 / ..3. longer recommended.  Wrap function in_parallel() declare performed parallel. See in_parallel() details. Use ... permitted context. ... Additional arguments passed mapped function. now generally recommend using ... pass additional (constant) arguments .f. Instead use shorthand anonymous function:   makes easier understand arguments belong function tend yield better error messages. .progress Whether show progress bar. Use TRUE turn basic progress bar, use string give name, see progress_bars details. .ptype NULL, default, output type common type elements result. Otherwise, supply \"prototype\" giving desired type output.","code":"# Instead of x |> map(f, 1, 2, collapse = \",\") # do: x |> map(\\(x) f(x, 1, 2, collapse = \",\"))"},{"path":"https://purrr.tidyverse.org/dev/reference/pmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map over multiple input simultaneously (in ","text":"output length determined maximum length elements .l. output names determined names first element .l. output type determined suffix: suffix: list; .f() can return anything. _lgl(), _int(), _dbl(), _chr() return logical, integer, double, character vector respectively; .f() must return compatible atomic vector length 1. _vec() return atomic S3 vector, type .f returns. .f can return pretty much type vector, long length 1. pwalk() returns input .l (invisibly). makes easy use pipe. return value .f() ignored. errors thrown .f wrapped error class purrr_error_indexed.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/pmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map over multiple input simultaneously (in ","text":"","code":"x <- list(1, 1, 1) y <- list(10, 20, 30) z <- list(100, 200, 300) pmap(list(x, y, z), sum) #> [[1]] #> [1] 111 #>  #> [[2]] #> [1] 221 #>  #> [[3]] #> [1] 331 #>   # Matching arguments by position pmap(list(x, y, z), function(first, second, third) (first + third) * second) #> [[1]] #> [1] 1010 #>  #> [[2]] #> [1] 4020 #>  #> [[3]] #> [1] 9030 #>   # Matching arguments by name l <- list(a = x, b = y, c = z) pmap(l, function(c, b, a) (a + c) * b) #> [[1]] #> [1] 1010 #>  #> [[2]] #> [1] 4020 #>  #> [[3]] #> [1] 9030 #>   # Vectorizing a function over multiple arguments df <- data.frame(   x = c(\"apple\", \"banana\", \"cherry\"),   pattern = c(\"p\", \"n\", \"h\"),   replacement = c(\"P\", \"N\", \"H\"),   stringsAsFactors = FALSE   ) pmap(df, gsub) #> [[1]] #> [1] \"aPPle\" #>  #> [[2]] #> [1] \"baNaNa\" #>  #> [[3]] #> [1] \"cHerry\" #>  pmap_chr(df, gsub) #> [1] \"aPPle\"  \"baNaNa\" \"cHerry\"  # Use `...` to absorb unused components of input list .l df <- data.frame(   x = 1:3,   y = 10:12,   z = letters[1:3] ) plus <- function(x, y) x + y if (FALSE) { # \\dontrun{ # this won't work pmap(df, plus) } # } # but this will plus2 <- function(x, y, ...) x + y pmap_dbl(df, plus2) #> [1] 11 13 15  # The \"p\" for \"parallel\" in pmap() is the same as in base::pmin() # and base::pmax() df <- data.frame(   x = c(1, 2, 5),   y = c(5, 4, 8) ) # all produce the same result pmin(df$x, df$y) #> [1] 1 2 5 map2_dbl(df$x, df$y, min) #> [1] 1 2 5 pmap_dbl(df, min) #> [1] 1 2 5"},{"path":"https://purrr.tidyverse.org/dev/reference/possibly.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrap a function to return a value instead of an error — possibly","title":"Wrap a function to return a value instead of an error — possibly","text":"Create modified version .f return default value (otherwise) whenever error occurs.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/possibly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrap a function to return a value instead of an error — possibly","text":"","code":"possibly(.f, otherwise = NULL, quiet = TRUE)"},{"path":"https://purrr.tidyverse.org/dev/reference/possibly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrap a function to return a value instead of an error — possibly","text":".f function modify, specified one following ways: named function, e.g. mean. anonymous function, e.g. \\(x) x + 1 function(x) x + 1. formula, e.g. ~ .x + 1. recommended require backward compatibility older versions R. otherwise Default value use error occurs. quiet Hide errors (TRUE, default), display occur?","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/possibly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrap a function to return a value instead of an error — possibly","text":"function takes arguments .f, returns different value, described .","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/possibly.html","id":"adverbs","dir":"Reference","previous_headings":"","what":"Adverbs","title":"Wrap a function to return a value instead of an error — possibly","text":"function called adverb modifies effect function (verb). like include function created adverb package, sure read faq-adverbs-export.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/possibly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrap a function to return a value instead of an error — possibly","text":"","code":"# To replace errors with a default value, use possibly(). list(\"a\", 10, 100) |>   map_dbl(possibly(log, NA_real_)) #> [1]       NA 2.302585 4.605170  # The default, NULL, will be discarded with `list_c()` list(\"a\", 10, 100) |>   map(possibly(log)) |>   list_c() #> [1] 2.302585 4.605170"},{"path":"https://purrr.tidyverse.org/dev/reference/prepend.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepend a vector — prepend","title":"Prepend a vector — prepend","text":"function deprecated purrr 1.0.0 related core purpose purrr. companion append() help merging two lists atomic vectors. prepend() clearer semantic signal c() vector merged beginning another, especially pipe chain.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/prepend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepend a vector — prepend","text":"","code":"prepend(x, values, before = NULL)"},{"path":"https://purrr.tidyverse.org/dev/reference/prepend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepend a vector — prepend","text":"x vector modified. values included modified vector. subscript, values appended. NULL, values appended beginning even x length 0.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/prepend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepend a vector — prepend","text":"merged vector.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/prepend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepend a vector — prepend","text":"","code":"x <- as.list(1:3)  x |> append(\"a\") #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] \"a\" #>  x |> prepend(\"a\") #> Warning: `prepend()` was deprecated in purrr 1.0.0. #> ℹ Please use append(after = 0) instead. #> [[1]] #> [1] \"a\" #>  #> [[2]] #> [1] 1 #>  #> [[3]] #> [1] 2 #>  #> [[4]] #> [1] 3 #>  x |> prepend(list(\"a\", \"b\"), before = 3) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] \"a\" #>  #> [[4]] #> [1] \"b\" #>  #> [[5]] #> [1] 3 #>  prepend(list(), x) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>"},{"path":"https://purrr.tidyverse.org/dev/reference/progress_bars.html","id":null,"dir":"Reference","previous_headings":"","what":"Progress bars in purrr — progress_bars","title":"Progress bars in purrr — progress_bars","text":"purrr's map functions .progress argument can use create progress bar. .progress can : FALSE, default: create progress bar. TRUE: creates basic unnamed progress bar. string: creates basic progress bar given name. named list progress bar parameters, described . good practice name progress bars, make clear calculation process belong . recommend keeping names 20 characters, whole progress bar fits comfortably even narrower displays.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/progress_bars.html","id":"progress-bar-parameters","dir":"Reference","previous_headings":"","what":"Progress bar parameters","title":"Progress bars in purrr — progress_bars","text":"clear: whether remove progress bar screen termination. Defaults TRUE. format: format string. overrides default format string progress bar type. must given custom type. Format strings may contain R expressions evaluate braces. support cli pluralization, styling can contain special progress variables. format_done: format string successful termination. default format. format_failed: format string unsuccessful termination. default format. name: progress bar name. default empty string displayed beginning progress bar. show_after: numeric scalar. show progress bar number seconds. overrides cli.progress_show_after global option. type: progress bar type. Currently supported types : iterator: default, loop mapping function, tasks: (typically small) number tasks, download: download one file, custom: custom type, format must NULL type. default display different progress bar type.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/progress_bars.html","id":"further-documentation","dir":"Reference","previous_headings":"","what":"Further documentation","title":"Progress bars in purrr — progress_bars","text":"purrr's progress bars powered cli, see Introduction progress bars cli Advanced cli progress bars details.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/purrr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"purrr: Functional Programming Tools — purrr-package","title":"purrr: Functional Programming Tools — purrr-package","text":"complete consistent functional programming toolkit R.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/purrr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"purrr: Functional Programming Tools — purrr-package","text":"Maintainer: Hadley Wickham hadley@posit.co (ORCID) Authors: Lionel Henry lionel@posit.co contributors: Posit Software, PBC (ROR) [copyright holder, funder]","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/purrr_error_indexed.html","id":null,"dir":"Reference","previous_headings":"","what":"Indexed errors (purrr_error_indexed) — purrr_error_indexed","title":"Indexed errors (purrr_error_indexed) — purrr_error_indexed","text":"purrr_error_indexed class thrown map(), map2(), pmap(), friends. wraps errors thrown processing individual elements information location error.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/purrr_error_indexed.html","id":"structure","dir":"Reference","previous_headings":"","what":"Structure","title":"Indexed errors (purrr_error_indexed) — purrr_error_indexed","text":"purrr_error_indexed three important fields: location: location error single integer. name: name location string. element named, name NULL parent: original error thrown .f. see action capturing generated condition simple example:   input vector named, name non-NULL:","code":"f <- function(x) {   rlang::abort(\"This is an error\") }  cnd <- rlang::catch_cnd(map(c(1, 4, 2), f)) class(cnd) #> [1] \"purrr_error_indexed\" \"rlang_error\"         \"error\" #> [4] \"condition\"  cnd$location #> [1] 1  cnd$name #> NULL  print(cnd$parent, backtrace = FALSE) #> <error/rlang_error> #> Error in `.f()`: #> ! This is an error cnd <- rlang::catch_cnd(map(c(a = 1, b = 4, c = 2), f)) cnd$name #> [1] \"a\""},{"path":"https://purrr.tidyverse.org/dev/reference/purrr_error_indexed.html","id":"handling-errors","dir":"Reference","previous_headings":"","what":"Handling errors","title":"Indexed errors (purrr_error_indexed) — purrr_error_indexed","text":"(section assumes familiar basics error handling R, described Advanced R.) error chaining really useful interactive data analysis, adds extra complexity handling errors tryCatch() withCallingHandlers(). see happens adding custom class error thrown f():   change visual display, might surprised try catch error tryCatch() withCallingHandlers():   , described , error map() throws always class purrr_error_indexed:   order handle error thrown f(), need use rlang::cnd_inherits() parent error:   (tryCatch() approach suboptimal longer just handling errors, also rethrowing . rethrown errors work correctly (e.g.) recover() traceback(), currently better approach. future expect enhance try_fetch() make easier 100% correctly). Finally, just want get rid purrr's wrapper error, can resignal parent error:   resignalling error, important use withCallingHandlers() tryCatch() order preserve full backtrace context. way recover(), traceback(), related tools continue work correctly.","code":"f <- function(x) {   rlang::abort(\"This is an error\", class = \"my_error\") } map(c(1, 4, 2, 5, 3), f) #> Error in `map()`: #> i In index: 1. #> Caused by error in `.f()`: #> ! This is an error tryCatch(   map(c(1, 4, 2, 5, 3), f),   my_error = function(err) {     # use NULL value if error     NULL   } ) #> Error in `map()`: #> i In index: 1. #> Caused by error in `.f()`: #> ! This is an error  withCallingHandlers(   map(c(1, 4, 2, 5, 3), f),   my_error = function(err) {     # throw a more informative error     abort(\"Wrapped error\", parent = err)   } ) #> Error in `map()`: #> i In index: 1. #> Caused by error in `.f()`: #> ! This is an error tryCatch(   map(c(1, 4, 2, 5, 3), f),   purrr_error_indexed = function(err) {     print(\"Hello! I am now called :)\")   } ) #> [1] \"Hello! I am now called :)\" tryCatch(   map(c(1, 4, 2, 5, 3), f),   purrr_error_indexed = function(err) {     if (rlang::cnd_inherits(err, \"my_error\")) {       NULL     } else {       rlang::cnd_signal(err)     }   } ) #> NULL  withCallingHandlers(   map(c(1, 4, 2, 5, 3), f),   purrr_error_indexed = function(err) {     if (rlang::cnd_inherits(err, \"my_error\")) {       abort(\"Wrapped error\", parent = err)     }   } ) #> Error: #> ! Wrapped error #> Caused by error in `map()`: #> i In index: 1. #> Caused by error in `.f()`: #> ! This is an error withCallingHandlers(   map(c(1, 4, 2, 5, 3), f),   purrr_error_indexed = function(err) {     rlang::cnd_signal(err$parent)   } ) #> Error in `.f()`: #> ! This is an error"},{"path":"https://purrr.tidyverse.org/dev/reference/quietly.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrap a function to capture side-effects — quietly","title":"Wrap a function to capture side-effects — quietly","text":"Create modified version .f captures side-effects along return value function returns list containing result, output, messages warnings.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/quietly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrap a function to capture side-effects — quietly","text":"","code":"quietly(.f)"},{"path":"https://purrr.tidyverse.org/dev/reference/quietly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrap a function to capture side-effects — quietly","text":".f function modify, specified one following ways: named function, e.g. mean. anonymous function, e.g. \\(x) x + 1 function(x) x + 1. formula, e.g. ~ .x + 1. recommended require backward compatibility older versions R.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/quietly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrap a function to capture side-effects — quietly","text":"function takes arguments .f, returns different value, described .","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/quietly.html","id":"adverbs","dir":"Reference","previous_headings":"","what":"Adverbs","title":"Wrap a function to capture side-effects — quietly","text":"function called adverb modifies effect function (verb). like include function created adverb package, sure read faq-adverbs-export.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/quietly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrap a function to capture side-effects — quietly","text":"","code":"f <- function() {   print(\"Hi!\")   message(\"Hello\")   warning(\"How are ya?\")   \"Gidday\" } f() #> [1] \"Hi!\" #> Hello #> Warning: How are ya? #> [1] \"Gidday\"  f_quiet <- quietly(f) str(f_quiet()) #> List of 4 #>  $ result  : chr \"Gidday\" #>  $ output  : chr \"[1] \\\"Hi!\\\"\" #>  $ warnings: chr \"How are ya?\" #>  $ messages: chr \"Hello\\n\""},{"path":"https://purrr.tidyverse.org/dev/reference/rate-helpers.html","id":null,"dir":"Reference","previous_headings":"","what":"Create delaying rate settings — rate-helpers","title":"Create delaying rate settings — rate-helpers","text":"helpers create rate settings can pass insistently() slowly(). can also use functions rate_sleep().","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/rate-helpers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create delaying rate settings — rate-helpers","text":"","code":"rate_delay(pause = 1, max_times = Inf)  rate_backoff(   pause_base = 1,   pause_cap = 60,   pause_min = 1,   max_times = 3,   jitter = TRUE )  is_rate(x)"},{"path":"https://purrr.tidyverse.org/dev/reference/rate-helpers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create delaying rate settings — rate-helpers","text":"pause Delay attempts seconds. max_times Maximum number requests attempt. pause_base, pause_cap rate_backoff() uses exponential back-request waits pause_base * 2^seconds, maximum pause_cap seconds. pause_min Minimum time wait backoff; generally necessary need pauses less one second (may kind server, use caution!). jitter Whether introduce random jitter waiting time. x object test.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/rate-helpers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create delaying rate settings — rate-helpers","text":"","code":"# A delay rate waits the same amount of time: rate <- rate_delay(0.02) for (i in 1:3) rate_sleep(rate, quiet = FALSE) #> Retrying in 0.02 seconds. #> Retrying in 0.02 seconds.  # A backoff rate waits exponentially longer each time, with random # jitter by default: rate <- rate_backoff(pause_base = 0.2, pause_min = 0.005) for (i in 1:3) rate_sleep(rate, quiet = FALSE) #> Retrying in 0.25 seconds. #> Retrying in 0.66 seconds."},{"path":"https://purrr.tidyverse.org/dev/reference/rate_sleep.html","id":null,"dir":"Reference","previous_headings":"","what":"Wait for a given time — rate_sleep","title":"Wait for a given time — rate_sleep","text":"rate's internal counter exceeds maximum number times allowed sleep, rate_sleep() throws error class purrr_error_rate_excess.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/rate_sleep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wait for a given time — rate_sleep","text":"","code":"rate_sleep(rate, quiet = TRUE)  rate_reset(rate)"},{"path":"https://purrr.tidyverse.org/dev/reference/rate_sleep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wait for a given time — rate_sleep","text":"rate rate object determining waiting time. quiet FALSE, prints message displaying long next request.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/rate_sleep.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wait for a given time — rate_sleep","text":"Call rate_reset() reset internal rate counter 0.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/rbernoulli.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate random sample from a Bernoulli distribution — rbernoulli","title":"Generate random sample from a Bernoulli distribution — rbernoulli","text":"function deprecated purrr 1.0.0 related core purpose purrr.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/rbernoulli.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate random sample from a Bernoulli distribution — rbernoulli","text":"","code":"rbernoulli(n, p = 0.5)"},{"path":"https://purrr.tidyverse.org/dev/reference/rbernoulli.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate random sample from a Bernoulli distribution — rbernoulli","text":"n Number samples p Probability getting TRUE","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/rbernoulli.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate random sample from a Bernoulli distribution — rbernoulli","text":"logical vector","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/rbernoulli.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate random sample from a Bernoulli distribution — rbernoulli","text":"","code":"rbernoulli(10) #>  [1] FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE rbernoulli(100, 0.1) #>   [1]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE #>  [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE #>  [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE #>  [34]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #>  [45] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #>  [56] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE #>  [67] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #>  [78] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE #>  [89] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #> [100] FALSE"},{"path":"https://purrr.tidyverse.org/dev/reference/rdunif.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate random sample from a discrete uniform distribution — rdunif","title":"Generate random sample from a discrete uniform distribution — rdunif","text":"function deprecated purrr 1.0.0 related core purpose purrr.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/rdunif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate random sample from a discrete uniform distribution — rdunif","text":"","code":"rdunif(n, b, a = 1)"},{"path":"https://purrr.tidyverse.org/dev/reference/rdunif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate random sample from a discrete uniform distribution — rdunif","text":"n Number samples draw. , b Range distribution (inclusive).","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/rdunif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate random sample from a discrete uniform distribution — rdunif","text":"","code":"table(rdunif(1e3, 10)) #> Warning: `rdunif()` was deprecated in purrr 1.0.0. #>  #>   1   2   3   4   5   6   7   8   9  10  #> 116  79  90 110  93  94 106  93 110 109  table(rdunif(1e3, 10, -5)) #>  #> -5 -4 -3 -2 -1  0  1  2  3  4  5  6  7  8  9 10  #> 64 54 58 48 63 73 74 55 52 72 65 63 60 60 64 75"},{"path":"https://purrr.tidyverse.org/dev/reference/reduce.html","id":null,"dir":"Reference","previous_headings":"","what":"Reduce a list to a single value by iteratively applying a binary function — reduce","title":"Reduce a list to a single value by iteratively applying a binary function — reduce","text":"reduce() operation combines elements vector single value. combination driven .f, binary function takes two values returns single value: reducing f 1:3 computes value f(f(1, 2), 3).","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/reduce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reduce a list to a single value by iteratively applying a binary function — reduce","text":"","code":"reduce(.x, .f, ..., .init, .dir = c(\"forward\", \"backward\"))  reduce2(.x, .y, .f, ..., .init)"},{"path":"https://purrr.tidyverse.org/dev/reference/reduce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reduce a list to a single value by iteratively applying a binary function — reduce","text":".x list atomic vector. .f reduce(), 2-argument function. function passed accumulated value first argument \"next\" value second argument. reduce2(), 3-argument function. function passed accumulated value first argument, next value .x second argument, next value .y third argument. reduction terminates early .f returns value wrapped done(). ... Additional arguments passed reduce function. now generally recommend using ... pass additional (constant) arguments .f. Instead use shorthand anonymous function:   makes easier understand arguments belong function tend yield better error messages. .init supplied, used first value start accumulation, rather using .x[[1]]. useful want ensure reduce returns correct value .x empty. missing, .x empty, throw error. .dir direction reduction string, one \"forward\" (default) \"backward\". See section direction . .y reduce2() additional argument passed .f. init set, .y 1 element shorter .x.","code":"# Instead of x |> reduce(f, 1, 2, collapse = \",\") # do: x |> reduce(\\(x, y) f(x, y, 1, 2, collapse = \",\"))"},{"path":"https://purrr.tidyverse.org/dev/reference/reduce.html","id":"direction","dir":"Reference","previous_headings":"","what":"Direction","title":"Reduce a list to a single value by iteratively applying a binary function — reduce","text":".f associative operation like + c(), direction reduction matter. instance, reducing vector 1:3 binary function + computes sum ((1 + 2) + 3) left, sum (1 + (2 + 3)) right. cases, direction important consequences reduced value. instance, reducing vector list() left produces left-leaning nested list (tree), reducing list() right produces right-leaning list.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/reduce.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reduce a list to a single value by iteratively applying a binary function — reduce","text":"","code":"# Reducing `+` computes the sum of a vector while reducing `*` # computes the product: 1:3 |> reduce(`+`) #> [1] 6 1:10 |> reduce(`*`) #> [1] 3628800  # By ignoring the input vector (nxt), you can turn output of one step into # the input for the next. This code takes 10 steps of a random walk: reduce(1:10, \\(acc, nxt) acc + rnorm(1), .init = 0) #> [1] -0.1895743  # When the operation is associative, the direction of reduction # does not matter: reduce(1:4, `+`) #> [1] 10 reduce(1:4, `+`, .dir = \"backward\") #> [1] 10  # However with non-associative operations, the reduced value will # be different as a function of the direction. For instance, # `list()` will create left-leaning lists when reducing from the # right, and right-leaning lists otherwise: str(reduce(1:4, list)) #> List of 2 #>  $ :List of 2 #>   ..$ :List of 2 #>   .. ..$ : int 1 #>   .. ..$ : int 2 #>   ..$ : int 3 #>  $ : int 4 str(reduce(1:4, list, .dir = \"backward\")) #> List of 2 #>  $ : int 1 #>  $ :List of 2 #>   ..$ : int 2 #>   ..$ :List of 2 #>   .. ..$ : int 3 #>   .. ..$ : int 4  # reduce2() takes a ternary function and a second vector that is # one element smaller than the first vector: paste2 <- function(x, y, sep = \".\") paste(x, y, sep = sep) letters[1:4] |> reduce(paste2) #> [1] \"a.b.c.d\" letters[1:4] |> reduce2(c(\"-\", \".\", \"-\"), paste2) #> [1] \"a-b.c-d\"  x <- list(c(0, 1), c(2, 3), c(4, 5)) y <- list(c(6, 7), c(8, 9)) reduce2(x, y, paste) #> [1] \"0 2 6 4 8\" \"1 3 7 5 9\"   # You can shortcircuit a reduction and terminate it early by # returning a value wrapped in a done(). In the following example # we return early if the result-so-far, which is passed on the LHS, # meets a condition: paste3 <- function(out, input, sep = \".\") {   if (nchar(out) > 4) {     return(done(out))   }   paste(out, input, sep = sep) } letters |> reduce(paste3) #> [1] \"a.b.c\"  # Here the early return branch checks the incoming inputs passed on # the RHS: paste4 <- function(out, input, sep = \".\") {   if (input == \"j\") {     return(done(out))   }   paste(out, input, sep = sep) } letters |> reduce(paste4) #> [1] \"a.b.c.d.e.f.g.h.i\""},{"path":"https://purrr.tidyverse.org/dev/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. rlang %||%, done, exec, is_atomic, is_bare_atomic, is_bare_character, is_bare_double, is_bare_integer, is_bare_list, is_bare_logical, is_bare_numeric, is_bare_vector, is_character, is_double, is_empty, is_formula, is_function, is_integer, is_list, is_logical, is_null, is_scalar_atomic, is_scalar_character, is_scalar_double, is_scalar_integer, is_scalar_list, is_scalar_logical, is_scalar_vector, is_vector, rep_along, set_names, zap","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/rerun.html","id":null,"dir":"Reference","previous_headings":"","what":"Re-run expressions multiple times — rerun","title":"Re-run expressions multiple times — rerun","text":"function deprecated purrr 1.0.0 believe NSE functions  good fit purrr. Also, rerun(n, x) can just easily expressed map(1:n, \\() x) rerun() convenient way generating sample data. works similarly replicate(..., simplify = FALSE).","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/rerun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Re-run expressions multiple times — rerun","text":"","code":"rerun(.n, ...)"},{"path":"https://purrr.tidyverse.org/dev/reference/rerun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Re-run expressions multiple times — rerun","text":".n Number times run expressions ... Expressions re-run.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/rerun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Re-run expressions multiple times — rerun","text":"list length .n. element ... re-run .n. one special case: single unnamed input, second level list dropped. case, rerun(n, x) behaves like replicate(n, x, simplify = FALSE).","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/rerun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Re-run expressions multiple times — rerun","text":"","code":"# old 5 |> rerun(rnorm(5)) |> str() #> Warning: `rerun()` was deprecated in purrr 1.0.0. #> ℹ Please use `map()` instead. #>   # Previously #>   rerun(5, rnorm(5)) #>  #>   # Now #>   map(1:5, ~ rnorm(5)) #> List of 5 #>  $ : num [1:5] 0.442 -1.019 -0.159 -1.638 2.839 #>  $ : num [1:5] 0.962 0.508 0.26 -0.773 -1.806 #>  $ : num [1:5] 0.1784 -0.5258 0.4002 -0.1226 -0.0713 #>  $ : num [1:5] 2.096 1.322 1.201 -0.782 -0.441 #>  $ : num [1:5] -0.246 0.3658 -0.0341 0.2962 -0.2211 # new 1:5 |> map(\\(i) rnorm(5)) |> str() #> List of 5 #>  $ : num [1:5] 0.1877 -0.4381 -0.0887 0.6343 0.8655 #>  $ : num [1:5] -0.4306 0.013 0.0512 0.5386 0.5197 #>  $ : num [1:5] -2.423 -0.806 -0.485 -0.653 -0.294 #>  $ : num [1:5] -0.27699 0.13647 1.06721 0.00183 0.14009 #>  $ : num [1:5] -0.521 2.366 -1.696 0.683 1.362  # old 5 |>   rerun(x = rnorm(5), y = rnorm(5)) |>   map_dbl(\\(l) cor(l$x, l$y)) #> Warning: `rerun()` was deprecated in purrr 1.0.0. #> ℹ Please use `map()` instead. #>   # Previously #>   rerun(5, x = rnorm(5), y = rnorm(5)) #>  #>   # Now #>   map(1:5, ~ list(x = rnorm(5), y = rnorm(5))) #> [1]  0.7025860 -0.7953249 -0.1909003  0.2530562 -0.1335784 # new 1:5 |>   map(\\(i) list(x = rnorm(5), y = rnorm(5))) |>   map_dbl(\\(l) cor(l$x, l$y)) #> [1]  0.1823376 -0.5566398  0.7327008 -0.3245149  0.5244111"},{"path":"https://purrr.tidyverse.org/dev/reference/safely.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrap a function to capture errors — safely","title":"Wrap a function to capture errors — safely","text":"Creates modified version .f always succeeds. returns list components result error. function succeeds, result contains returned value error NULL. error occurred, error error object result either NULL otherwise.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/safely.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrap a function to capture errors — safely","text":"","code":"safely(.f, otherwise = NULL, quiet = TRUE)"},{"path":"https://purrr.tidyverse.org/dev/reference/safely.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrap a function to capture errors — safely","text":".f function modify, specified one following ways: named function, e.g. mean. anonymous function, e.g. \\(x) x + 1 function(x) x + 1. formula, e.g. ~ .x + 1. recommended require backward compatibility older versions R. otherwise Default value use error occurs. quiet Hide errors (TRUE, default), display occur?","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/safely.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrap a function to capture errors — safely","text":"function takes arguments .f, returns different value, described .","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/safely.html","id":"adverbs","dir":"Reference","previous_headings":"","what":"Adverbs","title":"Wrap a function to capture errors — safely","text":"function called adverb modifies effect function (verb). like include function created adverb package, sure read faq-adverbs-export.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/safely.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrap a function to capture errors — safely","text":"","code":"safe_log <- safely(log) safe_log(10) #> $result #> [1] 2.302585 #>  #> $error #> NULL #>  safe_log(\"a\") #> $result #> NULL #>  #> $error #> <simpleError in .Primitive(\"log\")(x, base): non-numeric argument to mathematical function> #>   list(\"a\", 10, 100) |>   map(safe_log) |>   transpose() #> $result #> $result[[1]] #> NULL #>  #> $result[[2]] #> [1] 2.302585 #>  #> $result[[3]] #> [1] 4.60517 #>  #>  #> $error #> $error[[1]] #> <simpleError in .Primitive(\"log\")(x, base): non-numeric argument to mathematical function> #>  #> $error[[2]] #> NULL #>  #> $error[[3]] #> NULL #>  #>   # This is a bit easier to work with if you supply a default value # of the same type and use the simplify argument to transpose(): safe_log <- safely(log, otherwise = NA_real_) list(\"a\", 10, 100) |>   map(safe_log) |>   transpose() |>   simplify_all() #> $result #> [1]       NA 2.302585 4.605170 #>  #> $error #> $error[[1]] #> <simpleError in .Primitive(\"log\")(x, base): non-numeric argument to mathematical function> #>  #> $error[[2]] #> NULL #>  #> $error[[3]] #> NULL #>  #>"},{"path":"https://purrr.tidyverse.org/dev/reference/slowly.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrap a function to wait between executions — slowly","title":"Wrap a function to wait between executions — slowly","text":"slowly() takes function modifies wait given amount time call.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/slowly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrap a function to wait between executions — slowly","text":"","code":"slowly(f, rate = rate_delay(), quiet = TRUE)"},{"path":"https://purrr.tidyverse.org/dev/reference/slowly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrap a function to wait between executions — slowly","text":"f function modify, specified one following ways: named function, e.g. mean. anonymous function, e.g. \\(x) x + 1 function(x) x + 1. formula, e.g. ~ .x + 1. recommended require backward compatibility older versions R. rate rate object. Defaults constant delay. quiet Hide errors (TRUE, default), display occur?","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/slowly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrap a function to wait between executions — slowly","text":"function takes arguments .f, returns different value, described .","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/slowly.html","id":"adverbs","dir":"Reference","previous_headings":"","what":"Adverbs","title":"Wrap a function to wait between executions — slowly","text":"function called adverb modifies effect function (verb). like include function created adverb package, sure read faq-adverbs-export.","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/reference/slowly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrap a function to wait between executions — slowly","text":"","code":"# For these example, we first create a custom rate # with a low waiting time between attempts: rate <- rate_delay(0.1)  # slowly() causes a function to sleep for a given time between calls: slow_runif <- slowly(\\(x) runif(1), rate = rate, quiet = FALSE) out <- map(1:5, slow_runif) #> Retrying in 0.1 seconds. #> Retrying in 0.1 seconds. #> Retrying in 0.1 seconds. #> Retrying in 0.1 seconds."},{"path":"https://purrr.tidyverse.org/dev/reference/splice.html","id":null,"dir":"Reference","previous_headings":"","what":"Splice objects and lists of objects into a list — splice","title":"Splice objects and lists of objects into a list — splice","text":"function deprecated purrr 1.0.0 longer believe style implicit/automatic splicing good idea; instead use rlang::list2() + !!! list_flatten(). splice() splices arguments list. Non-list objects lists S3 class encapsulated list concatenation.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/splice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Splice objects and lists of objects into a list — splice","text":"","code":"splice(...)"},{"path":"https://purrr.tidyverse.org/dev/reference/splice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Splice objects and lists of objects into a list — splice","text":"... Objects concatenate.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/splice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Splice objects and lists of objects into a list — splice","text":"list.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/splice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Splice objects and lists of objects into a list — splice","text":"","code":"inputs <- list(arg1 = \"a\", arg2 = \"b\")  # splice() concatenates the elements of inputs with arg3 splice(inputs, arg3 = c(\"c1\", \"c2\")) |> str() #> Warning: `splice()` was deprecated in purrr 1.0.0. #> ℹ Please use `list_flatten()` instead. #> List of 3 #>  $ arg1: chr \"a\" #>  $ arg2: chr \"b\" #>  $ arg3: chr [1:2] \"c1\" \"c2\" list(inputs, arg3 = c(\"c1\", \"c2\")) |> str() #> List of 2 #>  $     :List of 2 #>   ..$ arg1: chr \"a\" #>   ..$ arg2: chr \"b\" #>  $ arg3: chr [1:2] \"c1\" \"c2\" c(inputs, arg3 = c(\"c1\", \"c2\")) |> str() #> List of 4 #>  $ arg1 : chr \"a\" #>  $ arg2 : chr \"b\" #>  $ arg31: chr \"c1\" #>  $ arg32: chr \"c2\""},{"path":"https://purrr.tidyverse.org/dev/reference/transpose.html","id":null,"dir":"Reference","previous_headings":"","what":"Transpose a list. — transpose","title":"Transpose a list. — transpose","text":"transpose() turns list--lists \"inside-\"; turns pair lists list pairs, list pairs pair lists. example, list length n component values b, transpose() make list elements b contained lists length n. called transpose x[[1]][[2]] equivalent transpose(x)[[2]][[1]]. function superseded purrr 1.0.0 list_transpose() better name can automatically simplify output, commonly needed. Superseded functions go away, receive critical bug fixes.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/transpose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transpose a list. — transpose","text":"","code":"transpose(.l, .names = NULL)"},{"path":"https://purrr.tidyverse.org/dev/reference/transpose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transpose a list. — transpose","text":".l list vectors transpose. first element used template; get warning subsequent element different length. .names efficiency, transpose() bases return structure first component .l default. Specify .names override .","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/transpose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transpose a list. — transpose","text":"list indexing transposed compared .l. transpose() inverse, much like transpose operation matrix. can get back original input transposing twice.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/transpose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transpose a list. — transpose","text":"","code":"x <- map(1:5, \\(i) list(x = runif(1), y = runif(5))) # was x |> transpose() |> str() #> List of 2 #>  $ x:List of 5 #>   ..$ : num 0.633 #>   ..$ : num 0.104 #>   ..$ : num 0.557 #>   ..$ : num 0.0568 #>   ..$ : num 0.915 #>  $ y:List of 5 #>   ..$ : num [1:5] 0.8332 0.3745 0.8264 0.1672 0.0548 #>   ..$ : num [1:5] 0.583 0.944 0.869 0.426 0.257 #>   ..$ : num [1:5] 0.1378 0.4203 0.2382 0.7582 0.0865 #>   ..$ : num [1:5] 0.308 0.677 0.925 0.265 0.304 #>   ..$ : num [1:5] 0.49922 0.26627 0.96272 0.00298 0.84882 # now x |> list_transpose(simplify = FALSE) |> str() #> List of 2 #>  $ x:List of 5 #>   ..$ : num 0.633 #>   ..$ : num 0.104 #>   ..$ : num 0.557 #>   ..$ : num 0.0568 #>   ..$ : num 0.915 #>  $ y:List of 5 #>   ..$ : num [1:5] 0.8332 0.3745 0.8264 0.1672 0.0548 #>   ..$ : num [1:5] 0.583 0.944 0.869 0.426 0.257 #>   ..$ : num [1:5] 0.1378 0.4203 0.2382 0.7582 0.0865 #>   ..$ : num [1:5] 0.308 0.677 0.925 0.265 0.304 #>   ..$ : num [1:5] 0.49922 0.26627 0.96272 0.00298 0.84882  # transpose() is useful in conjunction with safely() & quietly() x <- list(\"a\", 1, 2) y <- x |> map(safely(log)) # was y |> transpose() |> str() #> List of 2 #>  $ result:List of 3 #>   ..$ : NULL #>   ..$ : num 0 #>   ..$ : num 0.693 #>  $ error :List of 3 #>   ..$ :List of 2 #>   .. ..$ message: chr \"non-numeric argument to mathematical function\" #>   .. ..$ call   : language .Primitive(\"log\")(x, base) #>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\" #>   ..$ : NULL #>   ..$ : NULL # now: y |> list_transpose() |> str() #> List of 2 #>  $ result:List of 3 #>   ..$ : NULL #>   ..$ : num 0 #>   ..$ : num 0.693 #>  $ error :List of 3 #>   ..$ :List of 2 #>   .. ..$ message: chr \"non-numeric argument to mathematical function\" #>   .. ..$ call   : language .Primitive(\"log\")(x, base) #>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\" #>   ..$ : NULL #>   ..$ : NULL  # Previously, output simplification required a call to another function x <- list(list(a = 1, b = 2), list(a = 3, b = 4), list(a = 5, b = 6)) x |> transpose() |> simplify_all() #> $a #> [1] 1 3 5 #>  #> $b #> [1] 2 4 6 #>  # Now can take advantage of automatic simplification x |> list_transpose() #> $a #> [1] 1 3 5 #>  #> $b #> [1] 2 4 6 #>   # Provide explicit component names to prevent loss of those that don't # appear in first component ll <- list(   list(x = 1, y = \"one\"),   list(z = \"deux\", x = 2) ) ll |> transpose() #> $x #> $x[[1]] #> [1] 1 #>  #> $x[[2]] #> [1] 2 #>  #>  #> $y #> $y[[1]] #> [1] \"one\" #>  #> $y[[2]] #> NULL #>  #>  nms <- ll |> map(names) |> reduce(union) # was ll |> transpose(.names = nms) #> $x #> $x[[1]] #> [1] 1 #>  #> $x[[2]] #> [1] 2 #>  #>  #> $y #> $y[[1]] #> [1] \"one\" #>  #> $y[[2]] #> NULL #>  #>  #> $z #> $z[[1]] #> NULL #>  #> $z[[2]] #> [1] \"deux\" #>  #>  # now ll |> list_transpose(template = nms) #> $x #> [1] 1 2 #>  #> $y #> $y[[1]] #> [1] \"one\" #>  #> $y[[2]] #> NULL #>  #>  #> $z #> $z[[1]] #> NULL #>  #> $z[[2]] #> [1] \"deux\" #>  #>  # and can supply default value ll |> list_transpose(template = nms, default = NA) #> $x #> [1] 1 2 #>  #> $y #> [1] \"one\" NA    #>  #> $z #> [1] NA     \"deux\" #>"},{"path":"https://purrr.tidyverse.org/dev/reference/update_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Update a list with formulas — update_list","title":"Update a list with formulas — update_list","text":"update_list() deprecated purrr 1.0.0, longer believe functions use NSE good fit purrr. update_list() handles formulas quosures can refer values existing within input list. function deprecated longer believe functions use tidy evaluation good fit purrr.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/update_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update a list with formulas — update_list","text":"","code":"update_list(.x, ...)"},{"path":"https://purrr.tidyverse.org/dev/reference/update_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update a list with formulas — update_list","text":".x List modify. ... New values list. Use zap() remove values. values either named unnamed. inputs named, matched .x name. unnamed, matched position. Dynamic dots supported. particular, replacement values stored list, can splice !!!.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/when.html","id":null,"dir":"Reference","previous_headings":"","what":"Match/validate a set of conditions for an object and continue with the action associated with the first valid match. — when","title":"Match/validate a set of conditions for an object and continue with the action associated with the first valid match. — when","text":"function deprecated purrr 1.0.0 related core purpose purrr. can pull code pipe use regular /else statements instead. () flavour pattern matching (-else abstraction) value matched sequence condition-action sets. valid match/condition found action executed result action returned.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/when.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match/validate a set of conditions for an object and continue with the action associated with the first valid match. — when","text":"","code":"when(., ...)"},{"path":"https://purrr.tidyverse.org/dev/reference/when.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match/validate a set of conditions for an object and continue with the action associated with the first valid match. — when","text":". value match ... formulas; containing condition LHS action RHS. named arguments define additional values.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/when.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match/validate a set of conditions for an object and continue with the action associated with the first valid match. — when","text":"value resulting action first valid match/condition returned. matches found, default given, NULL returned. Validity conditions tested isTRUE, equivalently identical(condition, TRUE). words conditions resulting one logical never valid. Note input value always treated single object, opposed ifelse function.","code":""},{"path":"https://purrr.tidyverse.org/dev/reference/when.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match/validate a set of conditions for an object and continue with the action associated with the first valid match. — when","text":"","code":"1:10 |>   when(     sum(.) <=  50 ~ sum(.),     sum(.) <= 100 ~ sum(.)/2,     ~ 0   ) #> Warning: `when()` was deprecated in purrr 1.0.0. #> ℹ Please use `if` instead. #> [1] 27.5  # now x <- 1:10 if (sum(x) < 10) {   sum(x) } else if (sum(x) < 100) {   sum(x) / 2 } else {   0 } #> [1] 27.5"},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-development-version","dir":"Changelog","previous_headings":"","what":"purrr (development version)","title":"purrr (development version)","text":"list_flatten() gains is_node parameter taking predicate function determines whether input element node leaf (@salim-b, #1179). in_parallel() now accepts objects, including helper functions, supplied ... locally-defined functions (#1208). in_parallel() now works conjunction string list values supplied .progress argument map functions (#1203). functions soft-deprecated purrr 1.0.0 now fully deprecated. removed future release. includes: invoke_*(), lift_*(), cross*(), prepend(), splice(), rbernoulli(), rdunif(), (), update_list(), *_raw(), vec_depth(). map_chr() longer coereces logical, integer, double strings. functions arguments deprecated purrr 0.3.0 now removed. includes %@%, accumulate_right(), at_depth(), cross_d(), cross_n(), reduce2_right(), reduce_right().","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-110","dir":"Changelog","previous_headings":"","what":"purrr 1.1.0","title":"purrr 1.1.0","text":"CRAN release: 2025-07-10 purrr now requires R >= 4.1, can rely base pipe lambda syntax (#1177). purrr gains in_parallel() support parallel distributed maps, powered {mirai}. See ?in_parallel details (@shikokuchuo, #1163, #1185).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-104","dir":"Changelog","previous_headings":"","what":"purrr 1.0.4","title":"purrr 1.0.4","text":"CRAN release: 2025-02-05","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-103","dir":"Changelog","previous_headings":"","what":"purrr 1.0.3","title":"purrr 1.0.3","text":"Varies fixed bring purrr back compliance R CMD check (@shikokuchuo, @jayhesselberth). Added missing imap_vec() (#1084) list_transpose() now asserts work data frames (@KimLopezGuell, #1141, #1149), inspects elements determine correct template provided user (#1128, @krlmlr).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-102","dir":"Changelog","previous_headings":"","what":"purrr 1.0.2","title":"purrr 1.0.2","text":"CRAN release: 2023-08-10 Fixed valgrind issue. Deprecation infrastructure map_chr() now much less overhead leading improved performance (#1089). purrr now requires R 3.5.0.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-101","dir":"Changelog","previous_headings":"","what":"purrr 1.0.1","title":"purrr 1.0.1","text":"CRAN release: 2023-01-10 purrr 1.0.0, map() family functions wraps errors generated .f inside wrapper error tracks iteration index. purrr 1.0.1, error now custom class (purrr_error_indexed), location name fields, documented ?purrr_error_indexed (#1027). map() errors named inputs also report name element errored. Fixed issue progress bars weren’t closed user interrupts errors encountered map() call (#1024). Fixed invalid C signature pluck() (#1018). Set Biarch: true build purrr 32-bit Windows R < 4.2.0 (#1017).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-100","dir":"Changelog","previous_headings":"","what":"purrr 1.0.0","title":"purrr 1.0.0","text":"CRAN release: 2022-12-20","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"core-purpose-refinements-1-0-0","dir":"Changelog","previous_headings":"Breaking changes","what":"Core purpose refinements","title":"purrr 1.0.0","text":"cross() variants deprecated favour tidyr::expand_grid(). functions slow buggy longer think right approach solving problem. See #768 information. update_list() (#858) rerun() (#877), use tidyselect map_at() friends (#874) deprecated. functions use form non-standard evaluation now believe poor fit purrr. lift_* family functions deprecated. longer believe good fit purrr rely style function manipulation uncommon R code (#871). prepend(), rdunif(), rbernoulli(), (), list_along() deprecated (#925). ’s now clear don’t align core purpose purrr. splice() deprecated longer believe automatic splicing makes good UI. Instead use list2() + !!! list_flatten() (#869).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"mapping-1-0-0","dir":"Changelog","previous_headings":"Breaking changes","what":"Mapping","title":"purrr 1.0.0","text":"Use map functions expressions, calls, pairlists deprecated (#961). map _raw() variants deprecated limited use can now use map_vec() instead (#903). map_chr(), automatic conversion logical, integer, double character now deprecated. Use explicit .character() needed (#904). Errors .f now wrapped additional class gives information error occurred (#945).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"deprecation-next-steps-1-0-0","dir":"Changelog","previous_headings":"Breaking changes","what":"Deprecation next steps","title":"purrr 1.0.0","text":"as_function() ...f argument partial() longer supported. defunct quite time. Soft deprecated functions: %@%, reduce_right(), reduce2_right(), accumulate_right() now fully deprecated. Similarly, .lazy, .env, .first arguments partial(), .right argument detect() detect_index() fully deprecated. Removing elements NULL list_modify() list_merge() now fully deprecated. is_numeric() is_scalar_numeric() removed. deprecated since purrr 0.2.3 (Sep 2017). invoke_*() now deprecated. superseded 0.3.0 (Jan 2019) 3.5 years later, decided deprecate part API refinement 1.0.0 release. map_call() removed. made defunct 0.3.0 (Jan 2019).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"new-features-1-0-0","dir":"Changelog","previous_headings":"","what":"New features","title":"purrr 1.0.0","text":"*_at() can now take function (formula) ’s passed vector element names returns elements select. New map_vec(), map2_vec(), pmap_vec() work types vectors, extending map_lgl(), map_int(), friends can easily work dates, factors, date-times (#435). New keep_at() discard_at() work like keep() discard() operation element names rather element contents (#817). mapping functions now .progress argument create progress bar. See ?progress_bars (#149). purrr now licensed MIT (#805). modify(), modify_if(), modify_at(), modify2() longer generics. discovered simple implementation longer requires genericity methods provided small number packages (#894). purrr now uses base pipe (|>) anonymous function short hand (\\(x)), examples. means examples longer work R 4.0 earlier versions R, examples automatically converted regular section note might work (#936). map functions fail, now report element failed (#945). New modify_tree() recursively modifying nested data structures (#720).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"flattening-and-simplification-1-0-0","dir":"Changelog","previous_headings":"New features","what":"Flattening and simplification","title":"purrr 1.0.0","text":"New list_c(), list_rbind(), list_cbind() make easy c(), rbind(), cbind() elements list. New list_simplify() reduces list length-1 vectors simpler atomic S3 vector (#900). New list_transpose() automatically simplifies possible (#875). accumulate() accumulate2() now simplify output possible using vctrs. New arguments simplify ptype allow control details simplification (#774, #809). flatten() friends superseded favour list_flatten(), list_c(), list_cbind(), list_rbind(). *_dfc() *_dfr() superseded favour using appropriate map function along list_rbind() list_cbind() (#912). simplify(), simplify_all(), as_vector() superseded favour list_simplify(). provides consistent definition simplification (#900). transpose() superseded favour list_transpose() (#875). built-simplification.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"tidyverse-consistency-1-0-0","dir":"Changelog","previous_headings":"New features","what":"Tidyverse consistency","title":"purrr 1.0.0","text":"_lgl(), _int(), _int(), _dbl() now use (strict) coercion methods vctrs (#904). means : map_chr(TRUE, identity), map_chr(0L, identity), map_chr(1L, identity) deprecated now believe converting logical/integer/double character vector require explicit coercion. map_int(1.5, identity) now fails believe silently truncating doubles integers dangerous. note map_int(1, identity) still works since numeric precision lost. map_int(c(TRUE, FALSE), identity), map_dbl(c(TRUE, FALSE), identity), map_lgl(c(1L, 0L), identity) map_lgl(c(1, 0), identity) now succeed 1/TRUE 0/FALSE interchangeable. map2(), modify2(), pmap() now use tidyverse recycling rules vectors length 1 recycled size others must length (#878). map2() pmap() now recycle names first input needed (#783). modify(), modify_if(), modify_at() reimplemented using vctrs principles. shouldn’t user facing impact, make implementation much simpler.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"plucking-1-0-0","dir":"Changelog","previous_headings":"New features","what":"Plucking","title":"purrr 1.0.0","text":"vec_depth() now pluck_depth() works types input (#818). pluck() now requires indices length 1 (#813). also now reports correct type supply unexpected index. pluck() now accepts negative integers, indexing right (#603). pluck() chuck() now fail provide named inputs … (#788). pluck() longer replaces 0-length vectors default; now applies absent NULL components (#480). pluck<-/assign_in() can now modify non-existing locations (#704).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"setting-with-null-1-0-0","dir":"Changelog","previous_headings":"New features","what":"Setting with NULL","title":"purrr 1.0.0","text":"pluck<-/assign_in() now sets elements NULL rather removing (#636). Now use explicit zap() want remove elements. modify(), modify2(), modify_if() now correctly handle NULLs replacement values (#655, #746, #753). list_modify()’s interface standardised. Modifying NULL now always creates NULL output (#810)","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"list_-functions-1-0-0","dir":"Changelog","previous_headings":"New features","what":"list_ functions","title":"purrr 1.0.0","text":"New list_assign() similar list_modify() doesn’t work recursively (#822). list_modify() longer recurses data frames (objects built top lists fundamentally non-list like) (#810). can revert previous behaviour setting .is_node = .list.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"minor-improvements-and-bug-fixes-1-0-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"purrr 1.0.0","text":"capture_output() correctly uses conditionMessage() instead directly interrogating message field (#1010). modify() longer works calls pairlists. modify_depth() longer generic. makes consistent map_depth(). map_depth() modify_depth() new is_node argument allows control counts level. default uses vec_is_list() avoid recursing rich S3 objects like linear models data.frames (#958, #920). map_depth() modify_depth() now correctly recurse depth 1. as_mapper() now around twice fast used character, integer, list (#820). possibly() now defaults otherwise NULL. modify_if(.else) now actually evaluated atomic vectors (@mgirlich, #701). lmap_if() correctly handles .else functions (#847). every() now correctly propagates missing values using rules && (#751). Internally, become wrapper around &&. makes consistent && also () always wrapper around || propagation rules. every() () now properly check return value predicate function. must now return TRUE, FALSE, NA. Greatly improved performance functions created partial() (#715). invocation now fast functions creating manually. partial() longer inlines function call stack. fixes issues partial() used lm() instance (#707).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-035","dir":"Changelog","previous_headings":"","what":"purrr 0.3.5","title":"purrr 0.3.5","text":"CRAN release: 2022-10-06 Fixes CRAN checks.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-034","dir":"Changelog","previous_headings":"","what":"purrr 0.3.4","title":"purrr 0.3.4","text":"CRAN release: 2020-04-17 Fixed issue list_modify() prevented lists removed zap() (@adamroyjones, #777). Added documentation exporting functions created purrr adverb (@njtierney, #668). See ?faq-adverbs-export. Added none(), tests predicate false elements (opposite every()) (@AliciaSchep, #735).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-033","dir":"Changelog","previous_headings":"","what":"purrr 0.3.3","title":"purrr 0.3.3","text":"CRAN release: 2019-10-18 Maintenance release. documentation map() variants improved @surdina part Tidyverse Developer Day (@surdina, #671). purrr now depends R 3.2 greater.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-032","dir":"Changelog","previous_headings":"","what":"purrr 0.3.2","title":"purrr 0.3.2","text":"CRAN release: 2019-03-15 Fix protection issues reported rchk.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-031","dir":"Changelog","previous_headings":"","what":"purrr 0.3.1","title":"purrr 0.3.1","text":"CRAN release: 2019-03-03 reduce() now forces arguments (#643). Fixed issue partial() generic functions (#647). negate() now works generic functions functions early returns. compose() now works generic functions (#629, #639). set unit tests expanded cover many edge cases. prepend() now works empty lists (@czeildi, #637)","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-030","dir":"Changelog","previous_headings":"","what":"purrr 0.3.0","title":"purrr 0.3.0","text":"CRAN release: 2019-01-27","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"breaking-changes-0-3-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"purrr 0.3.0","text":"modify() variants now wrapping [[<- instead [<-. change increases genericity functions might cause different behaviour cases. instance, [[<- data frames stricter [<- method might throw errors instead warnings. case assigning longer vector number rows. [<- truncates vector warning, [[<- fails error (appropriate). modify() variants now return type input input atomic vector. functionals taking predicate functions (like keep(), detect(), ()) got stricter. Predicate functions must now return single TRUE FALSE. change meant detect problems early meaningful error message.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"plucking-0-3-0","dir":"Changelog","previous_headings":"","what":"Plucking","title":"purrr 0.3.0","text":"New chuck() function. strict variant pluck() throws errors element exist instead returning NULL (@daniel-barnett, #482). New assign_in() pluck<- functions. modify data structure existing pluck location. New modify_in() function map function pluck location. pluck() now dispatches properly S3 vectors. vector class must implement length() method numeric indexing names() method string indexing. pluck() now supports primitive functions (#404).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"mapping-0-3-0","dir":"Changelog","previous_headings":"","what":"Mapping","title":"purrr 0.3.0","text":"New .else argument map_if() modify_if(). take alternative function mapped elements input predicate function returns FALSE (#324). reduce(), reduce2(), accumulate(), accumulate2() now terminate early function returns value wrapped done() (#253). empty done() returned, value last iteration returned instead. Functions taking predicates (map_if(), keep(), (), every(), keep(), etc) now fail informative message return value TRUE FALSE (#470). breaking change every() () documented liberal values accepted logical (vector considered TRUE single FALSE value, matter length). functions signal soft-deprecation warnings instead hard failure. Edit (purr 0.4.0): every() () never issued deprecation warnings technical issue. didn’t fix warnings end, using predicates returning NA longer considered deprecated. need use every() () contexts NA propagation unsafe, e.g. () conditions, make sure use safe predicate functions like is_true(). modify() variants now implemented using length(), [[, [[<- methods. implementation compatible vector classes. New modify2() imodify() functions. work like map() imap() preserve type .x return value. pmap() pwalk() now preserve class inputs factor, Date, POSIXct atomic S3 classes appropriate [[ method (#358, @mikmart). modify(), modify_if() modify_at() now preserve class atomic vectors instead promoting lists. New S3 methods provided character, logical, double, integer classes (@t-kalinowski, #417). popular request, at_depth() brought back map_depth(). Like modify_depth(), applies function specified level data structure. However, transforms traversed vectors .depth bare lists (#381). map_at(), modify_at() lmap_at() accept negative values ., ignoring elements positions. map() modify() now work calls pairlists (#412). modify_depth() now modifies atomic leaves well. makes modify_depth(x, 1, fn) equivalent modify(x, fn) (#359). New accumulate2() function accumulate() reduce2() reduce().","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"rates-0-3-0","dir":"Changelog","previous_headings":"","what":"Rates","title":"purrr 0.3.0","text":"New rate_backoff() rate_delay() functions create rate objects. can pass rates insistently(), slowly(), lower level function rate_sleep(). cause function wait given amount time exponential backoff (increasingly larger waiting times) constant delay. insistently(f) modifies function, f, repeatedly called succeeds (@richierocks, @ijlyttle). slowly() modifies function waits given amount time calls.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"partial-0-3-0","dir":"Changelog","previous_headings":"","what":"partial()","title":"purrr 0.3.0","text":"interface partial() simplified. now supports quasiquotation control timing evaluation, rlang::call_modify() syntax control position partialised arguments. partial() now supports empty ... = argument specify position future arguments, relative partialised ones. syntax borrowed (implemented ) rlang::call_modify(). prevent partial matching ... ...f, latter renamed .f, consistent purrr function signatures. partial() now supports quasiquotation. unquote argument, evaluated function creation time. flexible .lazy argument since can control timing evaluation argument. Consequently, .lazy soft-deprecated (#457). Fixed infinite loop partialised function given name original function (#387). partial() now calls as_closure() primitive functions ensure argument matching (#360). .lazy argument partial() soft-deprecated favour quasiquotation:","code":"# Before partial(fn, u = runif(1), n = rnorm(1), .lazy = FALSE)  # After partial(fn, u = !!runif(1), n = !!rnorm(1))  # All constant partial(fn, u = !!runif(1), n = rnorm(1))    # First constant"},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"minor-improvements-and-fixes-0-3-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and fixes","title":"purrr 0.3.0","text":"tibble package now Suggests rather Imports. brings hard dependency purrr just rlang magrittr. compose() now returns identity function called without inputs. Functions created compose() now formal parameters first function called. also feature informative print method prints composed functions turn (@egnha, #366). New .dir argument compose(). set \"forward\", functions composed left right rather right left. list_modify() now supports zap() sentinel (reexported rlang) remove elements lists. Consequently, removing elements ambiguous sentinel NULL soft-deprecated. requirements list_modify() list_merge() relaxed. Previously required modified lists inputs either named unnamed. restriction now applies inputs .... inputs named, matched list name. unnamed, matched positionally. Otherwise, error. Fixed ordering names returned accumulate_right() output. now correspond order inputs. Fixed names accumulate() output .init supplied. compose() now supports composition lambdas (@ColinFay, #556) Fixed pmap() crash empty lists Win32 platform (#565). modify_depth now .ragged argument evaluates correctly TRUE default .depth < 0 (@cderv, #530). accumulate() now inherits names first input (@AshesITR, #446). attr_getter() longer uses partial matching. example, x object labels attribute label attribute, attr_getter(\"label\")(x) longer extract labels attribute (#460, @huftis). flatten_dfr() flatten_dfc() now aborts dplyr installed. (#454) imap_dfr() now works .id argument provided (#429) list_modify(), update_list() list_merge() now handle duplicate duplicate argument names correctly (#441, @mgirlich). map_raw, imap_raw, flatten_raw, invoke_map_raw, map2_raw pmap_raw added support raw vectors. (#455, @romainfrancois) flatten() now supports raw complex elements. array_branch() array_tree() now retain dimnames() input array (#584, @flying-sheep) pluck() longer flattens lists arguments. can still manually !!!. change consistency dots-collecting functions tidyverse. map_at(), lmap_at() modify_at() now supports selection using vars() tidyselect (@ColinFay, #608). Note now need import vars() dplyr call qualified like dplyr::vars(). reexported rlang future release. detect() now .default argument specify value returned nothing detected (#622, @ColinFay).","code":""},{"path":[]},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"dir-arguments-0-3-0","dir":"Changelog","previous_headings":"Life cycle","what":".dir arguments","title":"purrr 0.3.0","text":"standardised purrr API reverse iteration common .dir argument. reduce_right() soft-deprecated replaced new .dir argument reduce(): ```{r} # : reduce_right(1:3, f) CRAN release: 2019-01-27 reduce(1:3, f, .dir = “backward”) reduce2_right() soft-deprecated without replacement. clear algorithmic properties right reduction case. Please reach know use case right reduction ternary function. accumulate_right() soft-deprecated replaced new .dir argument accumulate(). Note algorithm slightly changed: accumulated value passed right rather left, consistent right reduction. ```{r} # : accumulate_right(1:3, f) CRAN release: 2019-01-27 accumulate(1:3, f, .dir = “backward”) ``` .right argument detect() detect_index() soft-deprecated renamed .dir consistency functions clarity interface. ```{r} # detect(x, f, .right = TRUE) CRAN release: 2019-01-27 detect(x, f, .dir = “backward”) ```","code":"Note that the details of the computation have changed. Whereas `reduce_right()` computed `f(f(3, 2), 1)`, it now computes `f(1, f(2, 3))`. This is the standard way of reducing from the right.  To produce the exact same reduction as `reduce_right()`, simply reverse your vector and use a left reduction:  ```{r} # Before: reduce_right(1:3, f)  # After: reduce(rev(1:3), f)"},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"simplification-of-partial-0-3-0","dir":"Changelog","previous_headings":"Life cycle","what":"Simplification of partial()","title":"purrr 0.3.0","text":"interface partial() simplified (see partial() ): .lazy argument partial() soft-deprecated favour quasiquotation. rename ...f .f partial() order support ... = argument (otherwise partial-match ...f). also makes partial() consistent purrr function signatures.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"retirement-of-invoke-0-3-0","dir":"Changelog","previous_headings":"Life cycle","what":"Retirement of invoke()","title":"purrr 0.3.0","text":"invoke() invoke_map() retired favour exec(). Note retired functions longer active development, continue maintained undefinitely package. invoke() retired favour exec() function, reexported rlang. exec() evaluates function call built inputs supports tidy dots: Note retired functions removed package maintained undefinitely. invoke_map() retired without replacement complex understand corresponding code using map(), map2() exec():","code":"# Before: invoke(mean, list(na.rm = TRUE), x = 1:10)  # After exec(mean, 1:10, !!!list(na.rm = TRUE)) # Before: invoke_map(fns, list(args)) invoke_map(fns, list(args1, args2))  # After: map(fns, exec, !!!args) map2(fns, list(args1, args2), function(fn, args) exec(fn, !!!args))"},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"other-lifecycle-changes-0-3-0","dir":"Changelog","previous_headings":"Life cycle","what":"Other lifecycle changes","title":"purrr 0.3.0","text":"%@% soft-deprecated, please use operator exported rlang instead. latter features interface consistent @ uses NSE, supports S4 fields, assignment variant. Removing elements lists using NULL list_modify() soft-deprecated. Please use new zap() sentinel reexported rlang instead: ```{r} # : list_modify(x, foo = NULL) # : list_modify(x, foo = zap()) ``` change motivated ambiguity NULL deletion sentinel NULL also valid value lists. future, NULL set element NULL rather removing element. rerun() now questioning stage longer convinced NSE functions good fit purrr. Also, rerun(n,   x) can just easily expressed map(1:n, ~ x) (added benefit passed current index argument lambda). map_call() defunct.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-025","dir":"Changelog","previous_headings":"","what":"purrr 0.2.5","title":"purrr 0.2.5","text":"CRAN release: 2018-05-29 maintenance release following release dplyr 0.7.5.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-024","dir":"Changelog","previous_headings":"","what":"purrr 0.2.4","title":"purrr 0.2.4","text":"CRAN release: 2017-10-18 Fixes R 3.1.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-023","dir":"Changelog","previous_headings":"","what":"purrr 0.2.3","title":"purrr 0.2.3","text":"CRAN release: 2017-08-02","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"breaking-changes-0-2-3","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"purrr 0.2.3","text":"noticed following issues reverse dependencies checks: reduce() fails message: Error: `.x` empty,   `.init` supplied, reduce() now returns .init .x empty. Fix problem supplying appropriate argument .init, providing special behaviour .x length 0. type predicates migrated rlang. Consequently bare-type-predicates documentation topic longer purrr, might cause warning cross-reference .","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"dependencies-0-2-3","dir":"Changelog","previous_headings":"","what":"Dependencies","title":"purrr 0.2.3","text":"purrr longer depends lazyeval Rcpp (dplyr, previous version). makes dependency graph tidyverse simpler, makes purrr suitable dependency lower-level packages. also two changes eliminate name conflicts purrr dplyr: order_by(), sort_by() split_by() removed. order_by() conflicted dplyr::order_by() complete family doesn’t feel useful. Use tibbles instead (#217). contains() renamed has_element() avoid conflicts dplyr (#217).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"pluck-0-2-3","dir":"Changelog","previous_headings":"","what":"pluck()","title":"purrr 0.2.3","text":"plucking mechanism used indexing data structures map() extracted function pluck(). Plucking often readable extract element buried deep data structure. Compare syntax-heavy extraction reads non-linearly: equivalent pluck:","code":"accessor(x[[1]])$foo x |> pluck(1, accessor, \"foo\")"},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"map-helpers-0-2-3","dir":"Changelog","previous_headings":"","what":"Map helpers","title":"purrr 0.2.3","text":"as_function() now as_mapper() tranformation makes sense primarily mapping functions, general (#298). .null renamed .default better reflect intent (#298). .default returned whenever element absent empty (#231, #254). as_mapper() sanitises primitive functions transforming closures standardised argument names (using rlang::as_closure()). instance + transformed function(.x, .y) .x + .y. results proper argument matching map(1:10, partial(-, .x = 5)) produces list(5 - 1, 5 - 2, ...). Recursive indexing can now extract objects environments (#213) S4 objects (#200), well lists. attr_getter() makes possible extract attributes like map(list(iris, mtcars), attr_getter(\"row.names\")). argument list formula-functions tweaked can refer arguments position ..1, ..2, . makes possible use formula shorthand functions two arguments (#289). possibly(), safely() friends longer capture interrupts: means can now terminate mapper using one Escape Ctrl + C (#314)","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"map-functions-0-2-3","dir":"Changelog","previous_headings":"","what":"Map functions","title":"purrr 0.2.3","text":"map functions now treat NULL way empty vector (#199), return empty vector input empty vector. map() functions now force arguments way base R lapply() (#191). makes map() etc easier use generating functions. new family “indexed” map functions, imap(), imap_lgl() etc, provide short-hand map2(x, names(x)) map2(x, seq_along(x)) (#240). data frame suffix _df (soft) deprecated favour _dfr clearly indicate ’s row-bind. variants now also _dfc column binding (#167). (terribly useful dplyr::bind_rows()/dplyr::bind_cols() better semantics vectors.)","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"modify-functions-0-2-3","dir":"Changelog","previous_headings":"","what":"Modify functions","title":"purrr 0.2.3","text":"new modify() family returns output type input .x. contrast map() family always returns list, regardless input type. modify functions S3 generics. However default methods sufficient classes since rely semantics [<-. modify.default() thus shorthand x[] <- map(x, f). at_depth() renamed modify_depth(). modify_depth() gains new .ragged argument, negative depths now computed relative deepest component list (#236).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"new-functions-0-2-3","dir":"Changelog","previous_headings":"","what":"New functions","title":"purrr 0.2.3","text":"auto_browse(f) returns new function automatically calls browser() f throws error (#281). vec_depth() computes depth (.e. number levels indexing) vector (#243). reduce2() reduce2_right() make possible reduce 3 argument function first argument accumulated value, second argument .x, third argument .y (#163). list_modify() extends stats::modifyList() replace position list named.(#201). list_merge() operates similarly list_modify() combines instead replacing (#322). legacy function update_list() basically version list_modify evaluates formulas within list. likely deprecated future favour tidyeval interface list method dplyr::mutate().","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"minor-improvements-and-bug-fixes-0-2-3","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"purrr 0.2.3","text":"Thanks @dchiu911, unit test coverage purrr now much greater. predicate functions re-exported rlang (#124). compact() now works standard mapper conventions (#282). cross_n() renamed cross(). _n suffix removed consistency pmap() (originally called map_n() start project) transpose() (originally called zip_n()). Similarly, cross_d() renamed cross_df() consistency map_df(). every() () now return NA present input (#174). invoke() uses robust approach generate argument list (#249) longer uses lazyeval figure enviroment character f comes . is_numeric() is_scalar_numeric() deprecated don’t test might expect first sight. reduce() now throws error .x empty .init supplied. Deprecated functions flatmap(), map3(), map_n(), walk3(), walk_n(), zip2(), zip3(), zip_n() removed. pmap() coerces data frames lists avoid expensive [.data.frame provides security unneeded (#220). rdunif() checks inputs validity (#211). set_names() can now take function tranform names programmatically (#276), can supply names ... reduce typing even (#316). set_names() now powered rlang::set_names(). safely() now actually uses quiet argument (#296). transpose() now matches name available (#164). can override default choice new .names argument. function argument detect() detect_index() renamed .p .f. mapper semantics rather predicate semantics.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-0221","dir":"Changelog","previous_headings":"","what":"purrr 0.2.2.1","title":"purrr 0.2.2.1","text":"compatibility release dplyr 0.6.0. data-frame based mappers removed favour new functions idioms tidyverse. dmap(), dmap_at(), dmap_if(), invoke_rows(), slice_rows(), map_rows(), by_slice(), by_row(), unslice() moved purrrlyr. bit aggresive change allows us make dependencies much lighter.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-022","dir":"Changelog","previous_headings":"","what":"purrr 0.2.2","title":"purrr 0.2.2","text":"CRAN release: 2016-06-18 Fix dev tibble support. as_function() now supports list arguments allow recursive indexing using either names positions. now always stop encountering first NULL (#173). accumulate reduce correctly pass extra arguments worker function.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-021","dir":"Changelog","previous_headings":"","what":"purrr 0.2.1","title":"purrr 0.2.1","text":"CRAN release: 2016-02-13 as_function() gains .null argument character numeric values allows specify return null/absent elements (#110). can used map function, e.g. map_int(x, 1, .null = NA) as_function() now generic. New is_function() returns TRUE regular functions. Fix crash GCC triggered invoke_rows().","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"purrr-020","dir":"Changelog","previous_headings":"","what":"purrr 0.2.0","title":"purrr 0.2.0","text":"CRAN release: 2016-01-04","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"new-functions-0-2-0","dir":"Changelog","previous_headings":"","what":"New functions","title":"purrr 0.2.0","text":"two handy infix functions: x %||% y shorthand (.null(x)) y else x (#109). x %@% \"\" shorthand attr(x, \"\", exact = TRUE) (#69). accumulate() added handle recursive folding. shortand Reduce(f, .x, accumulate = TRUE) follows similar syntax reduce() (#145). right-hand version accumulate_right() also added. map_df() row-binds output together. ’s equivalent plyr::ldply() (#127) flatten() now type-stable always returns list. return simpler vector, use flatten_lgl(), flatten_int(), flatten_dbl(), flatten_chr(), flatten_df(). invoke() overhauled useful: now works similarly map_call() .x NULL, hence map_call() deprecated. invoke_map() vectorised complement invoke() (#125), comes typed variants invoke_map_lgl(), invoke_map_int(), invoke_map_dbl(), invoke_map_chr(), invoke_map_df(). transpose() replaces zip2(), zip3(), zip_n() (#128). name clearly reflects intent (transposing first second levels list). longer fields argument .simplify argument; instead use new simplify_all() function. safely(), quietly(), possibly() experimental functions working functions side-effects (e.g. printed output, messages, warnings, errors) (#120). safely() version try() modifies function (rather expression), always returns list two components, result error. list_along() rep_along() generalise idea seq_along(). (#122). is_null() snake-case version .null(). pmap() (parallel map) replaces map_n() (#132), typed-variants suffixed pmap_lgl(), pmap_int(), pmap_dbl(), pmap_chr(), pmap_df(). set_names() snake-case alternative setNames() stricter equality checking, convenient defaults pipes: x |> set_names() equivalent setNames(x, x) (#119).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"row-based-functionals-0-2-0","dir":"Changelog","previous_headings":"","what":"Row based functionals","title":"purrr 0.2.0","text":"still figuring belongs dplyr belongs purrr. Expect much experimentation many changes functions. map() now always returns list. Data frame support moved map_df() dmap(). latter supports sliced data frames shortcut combination by_slice() dmap(): x |> by_slice(dmap, fun, .collate = \"rows\"). conditional variants dmap_at() dmap_if() also support sliced data frames recycle scalar results slice size. map_rows() renamed invoke_rows(). rows-based functionals, collates results inside lists default, column collation function equivalent plyr::mdply(). rows-based functionals gain .option name output column well .collate argument. latter allows collate output lists (default), columns rows. makes functions flexible predictable.","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"bug-fixes-and-minor-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor changes","title":"purrr 0.2.0","text":"as_function(), converts formulas etc functions, now exported (#123). rerun() correctly scoped (#95) update_list() can now modify element called x (#98). map*() now use custom C code, rather relying lapply(), mapply() etc. performance characteristcs similar, allows us greater control output (#118). map_lgl() now second argument .f, .p (#134).","code":""},{"path":"https://purrr.tidyverse.org/dev/news/index.html","id":"deprecated-functions-0-2-0","dir":"Changelog","previous_headings":"","what":"Deprecated functions","title":"purrr 0.2.0","text":"flatmap() -> use map() followed appropriate flatten(). map_call() -> invoke(). map_n() -> pmap(); walk_n() -> pwalk(). map3(x, y, z) -> map_n(list(x, y, z)); walk3(x, y, z) ->pwalk(list(x, y, z))`","code":""}]
