% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flatten.R
\name{flatten}
\alias{flatten}
\alias{flatten_lgl}
\alias{flatten_int}
\alias{flatten_dbl}
\alias{flatten_chr}
\alias{flatten_raw}
\alias{flatten_dfr}
\alias{flatten_dfc}
\alias{flatten_df}
\title{Flatten a list of lists into a simple vector.}
\usage{
flatten(.x)

flatten_lgl(.x)

flatten_int(.x)

flatten_dbl(.x)

flatten_chr(.x)

flatten_raw(.x)

flatten_dfr(.x, .id = NULL)

flatten_dfc(.x)
}
\arguments{
\item{.x}{A list to flatten. The contents of the list can be anything for
\code{flatten()} (as a list is returned), but the contents must match the
type for the other functions.}

\item{.id}{Either a string or \code{NULL}. If a string, the output will contain
a variable with that name, storing either the name (if \code{.x} is named) or
the index (if \code{.x} is unnamed) of the input. If \code{NULL}, the default, no
variable will be created.

Only applies to \verb{_dfr} variant.}
}
\value{
\code{flatten()} returns a list, \code{flatten_lgl()} a logical
vector, \code{flatten_int()} an integer vector, \code{flatten_dbl()} a
double vector, and \code{flatten_chr()} a character vector.

\code{flatten_dfr()} and \code{flatten_dfc()} return data frames created by
row-binding and column-binding respectively. They require dplyr to
be installed.
}
\description{
These functions remove a level hierarchy from a list. They are similar to
\code{\link[=unlist]{unlist()}}, but they only ever remove a single layer of hierarchy and they
are type-stable, so you always know what the type of the output is.
}
\examples{
x <- rerun(2, sample(4))
x
x \%>\% flatten()
x \%>\% flatten_int()

# You can use flatten in conjunction with map
x \%>\% map(1L) \%>\% flatten_int()
# But it's more efficient to use the typed map instead.
x \%>\% map_int(1L)
}
