% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map-depth.R
\name{map_depth}
\alias{map_depth}
\alias{modify_depth}
\title{Map/modify elements at given depth}
\usage{
map_depth(.x, .depth, .f, ..., .ragged = FALSE)

modify_depth(.x, .depth, .f, ..., .ragged = .depth < 0)
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.depth}{Level of \code{.x} to map on. Use a negative value to
count up from the lowest level of the list.
\itemize{
\item \code{map_depth(x, 0, fun)} is equivalent to \code{fun(x)}.
\item \code{map_depth(x, 1, fun)} is equivalent to \code{x <- map(x, fun)}
\item \code{map_depth(x, 2, fun)} is equivalent to \verb{x <- map(x, \\(y) map(y, fun))}
}}

\item{.f}{A function, specified in one of the following ways:
\itemize{
\item A named function, e.g. \code{mean}.
\item An anonymous function, e.g. \verb{\\(x) x + 1} or \code{function(x) x + 1}.
\item A formula, e.g. \code{~ .x + 1}. You must use \code{.x} to refer to the first
argument. Only recommended if you require backward compatibility with
older versions of R.
\item A string, integer, or list, e.g. \code{"idx"}, \code{1}, or \code{list("idx", 1)} which
are shorthand for \verb{\\(x) pluck(x, "idx")}, \verb{\\(x) pluck(x, 1)}, and
\verb{\\(x) pluck(x, "idx", 1)} respectively. Optionally supply \code{.default} to
set a default value if the indexed element is \code{NULL} or does not exist.
}}

\item{...}{Additional arguments passed on to the mapped function.

Note that the arguments that differ in each call come before \code{.f},
and the arguments that are the same come after \code{.f}.}

\item{.ragged}{If \code{TRUE}, will apply to leaves, even if they're not
at depth \code{.depth}. If \code{FALSE}, will throw an error if there are
no elements at depth \code{.depth}.}
}
\description{
\code{map_depth()} calls \code{map(.y, .f)} on all \code{.y} at the specified \code{.depth} in
\code{.x}. \code{modify_depth()} calls \code{modify(.y, .f)} on \code{.y} at the specified
\code{.depth} in \code{.x}.
}
\examples{
# map_depth() -------------------------------------------------
# Use `map_depth()` to recursively traverse nested vectors and map
# a function at a certain depth:
x <- list(a = list(foo = 1:2, bar = 3:4), b = list(baz = 5:6))
str(x)
map_depth(x, 2, paste, collapse = "/")

# Equivalent to:
map(x, map, paste, collapse = "/")

# When ragged is TRUE, `.f()` will also be passed leaves at depth < `.depth`
x <- list(1, list(1, list(1, list(1, 1))))
str(x)
str(map_depth(x, 4, \(x) length(unlist(x)), .ragged = TRUE))
str(map_depth(x, 3, \(x) length(unlist(x)), .ragged = TRUE))
str(map_depth(x, 2, \(x) length(unlist(x)), .ragged = TRUE))
str(map_depth(x, 1, \(x) length(unlist(x)), .ragged = TRUE))
str(map_depth(x, 0, \(x) length(unlist(x)), .ragged = TRUE))

# modify_depth() -------------------------------------------------
l1 <- list(
  obj1 = list(
    prop1 = list(param1 = 1:2, param2 = 3:4),
    prop2 = list(param1 = 5:6, param2 = 7:8)
  ),
  obj2 = list(
    prop1 = list(param1 = 9:10, param2 = 11:12),
    prop2 = list(param1 = 12:14, param2 = 15:17)
  )
)

# In the above list, "obj" is level 1, "prop" is level 2 and "param"
# is level 3. To apply sum() on all params, we map it at depth 3:
l1 |> modify_depth(3, sum) |> str()

# Note that vectorised operations will yield the same result when
# applied at the list level as when applied at the atomic result.
# The former is more efficient because it takes advantage of
# vectorisation.
l1 |> modify_depth(3, `+`, 100L)
l1 |> modify_depth(4, `+`, 100L)

# modify() lets us pluck the elements prop1/param2 in obj1 and obj2:
l1 |> modify(c("prop1", "param2")) |> str()

# But what if we want to pluck all param2 elements? Then we need to
# act at a lower level:
l1 |> modify_depth(2, "param2") |> str()

# modify_depth() can be with other purrr functions to make them operate at
# a lower level. Here we ask pmap() to map paste() simultaneously over all
# elements of the objects at the second level. paste() is effectively
# mapped at level 3.
l1 |> modify_depth(2, \(x) pmap(x, paste, sep = " / ")) |> str()
}
